/***
 * This is an autogenerated file. DO NOT EDIT THIS FILE OR YOUR CHANGES WILL BE OVERWRITTEN! 
 * If you wish to make changes here, please update the documentation in the bbm_doc git 
 * repository and then rerun the updateschema.py2 script. 
 */

using System;
using java.util.ArrayList;
using java.util.List;

using org.json.JSONException;
using org.json.JSONObject;

//using com.bbm.bbmds.internal.JsonConstructable;
//using com.bbm.bbmds.internal.ListDescriptor;
//using com.bbm.bbmds.internal.ListId;
//using com.bbm.bbmds.internal.ListProtocol;
//using com.bbm.bbmds.internal.ProtocolSchema;
//using com.bbm.bbmds.internal.ReferenceCache;
//using com.bbm.bbmds.internal.lists.ListMatchingCriteria;
using com.bbm.bbmds.FileTransferCriteria;
using com.bbm.bbmds.MessageCriteria;
using com.bbm.bbmds.PictureCriteria;
using com.bbm.bbmds.StickerCriteria;
using com.bbm.bbmds.StickerImageCriteria;
using com.bbm.bbmds.StickerPackCriteria;
using com.bbm.bbmds.UserBlockedItemCriteria;
//using com.bbm.bbmds.internal.maps.LiveMap;
using com.bbm.core.Broker;
using com.bbm.core.ProtocolException;
using com.bbm.core.ProtocolMessage;
using com.bbm.observers.ObservableValue;
using com.bbm.observers.StateAwareList;
using com.bbm.observers.StateAwareSparseList;
using com.bbm.observers.Tracked;
using com.bbm.observers.TrackedGetter;
using com.bbm.util.Existence;
using com.bbm.util.Global;
using com.bbm.util.JSONUtil;

namespace com.bbm.bbmds {

/// <summary>
/// Contains the schema and accessors for the bbmcore_to_ui protocol
/// </summary>
class BbmdsProtocol {
    private readonly ListProtocol mProtocol;
    
    // Optimization for singleton map-only lists: store them as member variables
    // to avoid the need to look them up on each access
    private readonly LiveMap<Channel> mChannel;
    private readonly LiveMap<ChannelStats> mChannelStats;
    private readonly LiveMap<Comment> mComment;
    private readonly LiveMap<Global> mGlobal;
    private readonly LiveMap<Message> mMessage;
    private readonly LiveMap<PinToUser> mPinToUser;
    private readonly LiveMap<Post> mPost;
    private readonly LiveMap<PostImage> mPostImage;
    private readonly LiveMap<Sticker> mSticker;
    private readonly LiveMap<StickerImage> mStickerImage;
    private readonly LiveMap<StickerPack> mStickerPack;
    private readonly LiveMap<TextMessageContext> mTextMessageContext;
    private readonly LiveMap<User> mUser;

    public BbmdsProtocol(Broker broker, ReferenceCache cache) {
        this.mProtocol = new ListProtocol(broker, createSchema(), cache);
        this.mChannel = mProtocol.getLiveMap(new ListId("channel"), typeof(Channel)).get();
        this.mChannelStats = mProtocol.getLiveMap(new ListId("channelStats"), typeof(ChannelStats)).get();
        this.mComment = mProtocol.getLiveMap(new ListId("comment"), typeof(Comment)).get();
        this.mGlobal = mProtocol.getLiveMap(new ListId("global"), typeof(Global)).get();
        this.mMessage = mProtocol.getLiveMap(new ListId("message"), typeof(Message)).get();
        this.mPinToUser = mProtocol.getLiveMap(new ListId("pinToUser"), typeof(PinToUser)).get();
        this.mPost = mProtocol.getLiveMap(new ListId("post"), typeof(Post)).get();
        this.mPostImage = mProtocol.getLiveMap(new ListId("postImage"), typeof(PostImage)).get();
        this.mSticker = mProtocol.getLiveMap(new ListId("sticker"), typeof(Sticker)).get();
        this.mStickerImage = mProtocol.getLiveMap(new ListId("stickerImage"), typeof(StickerImage)).get();
        this.mStickerPack = mProtocol.getLiveMap(new ListId("stickerPack"), typeof(StickerPack)).get();
        this.mTextMessageContext = mProtocol.getLiveMap(new ListId("textMessageContext"), typeof(TextMessageContext)).get();
        this.mUser = mProtocol.getLiveMap(new ListId("user"), typeof(User)).get();
}

    protected sealed ProtocolSchema getSchema() {
        return mProtocol.getSchema();
    }
    
    static class OutboundMessage {

        ProtocolMessage mMessage;

        OutboundMessage(string messageName) {
            mMessage = new ProtocolMessage(messageName, new JSONObject());
        }

        // AA: this method has "throws ProtocolException" clause and C# don't have equivalent conversion #FYI
        void put(string attrib, Object value) {
            try {
                mMessage.getData().put(attrib, JSONUtil.objectToJson(value));
            }
            catch (JSONException e) {
                throw new ProtocolException(e);
            }
        }

        public ProtocolMessage create() {
            return mMessage.copy();
        }
    };

    protected sealed ListProtocol getParser() {
        return mProtocol;
    }
    
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    protected sealed T getMapValue<T>(ListId id, string key, T clazz) where T : JsonConstructable {
            return mProtocol.getMapValue(id, key, clazz);
    }

    protected sealed StateAwareList<T> getList(ListId id, T clazz) where T : JsonConstructable {
        return mProtocol.getList(id, clazz);
    }

    protected sealed StateAwareSparseList<T> getSparseList<T>(ListId id, bool descending, T clazz) where T : JsonConstructable {
        return mProtocol.getSparseList(id, descending, clazz);
    }
    
    protected sealed StateAwareList<T> getListMatching(ListId id, T clazz, ListMatchingCriteria<T> criteria) where T : JsonConstructable {
        return mProtocol.getListMatching(id, clazz, criteria);
    }

    /// <summary>
    /// Sends an outgoing protocol message. See the rest of this class declaration for a list of valid outgoing message types.
    /// </summary>
    /// <param name="message">the message to send</param>
    public void send(OutboundMessage message) {
        mProtocol.getBroker().send(message.mMessage);
    }  
    

    protected abstract static class Msg {
        /// <summary>
        /// <p>
        /// Creates a new AdSend message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that the service sends an ad to a remote user. The service will create a new 
        /// entry in the message list that references the ad in bbmads_to_ui::ad list. 
        /// </p>
        /// </summary>
        /// <param name="adId">This is a foreign key to the bbmads_to_ui::ad list. It identifies the ad to share.</param>
        /// <param name="text">Contains a user-readable (untranslatable) text filled in by the local user. Possibly empty.</param>
        /// <param name="to">Contains a list of user URIs indicating the intended recipients of this message. The message should be added to an existing 1-on-1 conversation with the user. If no such conversation exists yet, it will be created, resulting in a listAdd message in the active conversations list. If the conversation exists (and is either a multi-chat or 1-on-1 chat), it is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        public static AdSend adSend(string adId, string text, List<string> to) {
            return new AdSend(adId, text, to);
        }

        /// <summary>
        /// This class represents an instance of the adSend protocol message
        /// </summary>
        public static sealed class AdSend : OutboundMessage {
            AdSend(string adId, string text, List<string> to) {
                super("adSend");
                
                put("adId", adId);
                put("text", text);
                put("to", to);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new BarcodeScreenState message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to indicate when the QR code screen is shown or 
        /// closed. When the screen is visible, a hash value is used for auto accepting 
        /// invitation that contains the same hash value. 
        /// </p>
        /// </summary>
        /// <param name="hash">Holds the current hash value. This value is used for auto accepting invitation when the screen is visible.</param>
        /// <param name="state">Holds the current state of the QR code screen.</param>
        public static BarcodeScreenState barcodeScreenState(string hash, string state) {
            return new BarcodeScreenState(hash, state);
        }

        /// <summary>
        /// This class represents an instance of the barcodeScreenState protocol message
        /// </summary>
        public static sealed class BarcodeScreenState : OutboundMessage {
            BarcodeScreenState(string hash, string state) {
                super("barcodeScreenState");
                
                put("hash", hash);
                put("state", state);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new BbidCredentials message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Provides core with the user's BBID credentials, and the device PIN if the localPin 
        /// global is empty. 
        /// </p>
        /// <p>
        /// 
        /// If application of the BBID credentials changes the bbidState global, core will 
        /// reply with an update to that global. 
        /// </p>
        /// <p>
        /// 
        /// If pin is provided core will attempt to update the localPin global. If a different 
        /// localPin already exists core will wipe and shutdown, otherwise the localPin will 
        /// be set and core will reply with an update to that global. 
        /// </p>
        /// </summary>
        /// <param name="ecoId">The user's BBID ecoId.</param>
        /// <param name="token">The user's BBID token.</param>
        public static BbidCredentials bbidCredentials(string ecoId, string token) {
            return new BbidCredentials(ecoId, token);
        }

        /// <summary>
        /// This class represents an instance of the bbidCredentials protocol message
        /// </summary>
        public static sealed class BbidCredentials : OutboundMessage {
            BbidCredentials(string ecoId, string token) {
                super("bbidCredentials");
                
                put("ecoId", ecoId);
                put("token", token);
            }

            /// <summary>
            /// Sets the optional 'pin' attribute on the message
            /// </summary>
            /// <param name="value">The user's device PIN.  Required if localPin global is empty.</param>
            /// <returns>this</returns>
            public BbidCredentials pin(string value) {
                put("pin", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelBlockUser message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests to block/unblock the user from channel. Successful call will result in a 
        /// listChange on channel list with blocked state changed. 
        /// </p>
        /// <p>
        /// 
        /// If an error occurs, then a 'channelBlockUserError' message describing the error 
        /// is sent to the client. Receiving an error does not preclude the blocking record 
        /// being updated. 
        /// </p>
        /// <p>
        /// 
        /// If the user is not blocked in the channel, that is considered to be an error. 
        /// </p>
        /// <p>
        /// 
        /// An owner cannot block himself from the channel. 
        /// </p>
        /// </summary>
        /// <param name="block">This boolean flag is to indicate this is a block or unblock action.</param>
        /// <param name="channelUri">The URI of the channel to update the subscription. The URI given must be unique across the entire BBM Channels infrastructure. Updating channels pending creation is not supported.</param>
        /// <param name="commentId">The commentId of the user to block. It should be userUri but currently there is server restrictions that the API only takes commentId.</param>
        /// <param name="postId">The post id that the comment lives in, this is a work around because we take the commentId approach to block user. Once changed to userUri we can remove this.</param>
        public static ChannelBlockUser channelBlockUser(bool block, string channelUri, string commentId, string postId) {
            return new ChannelBlockUser(block, channelUri, commentId, postId);
        }

        /// <summary>
        /// This class represents an instance of the channelBlockUser protocol message
        /// </summary>
        public static sealed class ChannelBlockUser : OutboundMessage {
            ChannelBlockUser(bool block, string channelUri, string commentId, string postId) {
                super("channelBlockUser");
                
                put("block", block);
                put("channelUri", channelUri);
                put("commentId", commentId);
                put("postId", postId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelClearNotifications message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Clear channel notifications with the specified type, channelUri and postId. 
        /// Core should respond with listRemove messages for each deleted channel 
        /// notification. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The unique identifier of the channel. This Uri was assigned by the BBM Channels infrastructure when the channel was created and it must be unique across the entire BBM Channels infrastructure.</param>
        /// <param name="type">The type of channel notifications to be cleared. If the type is 'Channel', core will clear all channel notifications related to the specified channel e.g. FavoriteChannelPost notification. If the type is 'Post', core will clear all channel notifications related to a post e.g. CommentOnPost notification.</param>
        public static ChannelClearNotifications channelClearNotifications(string channelUri, string type) {
            return new ChannelClearNotifications(channelUri, type);
        }

        /// <summary>
        /// This class represents an instance of the channelClearNotifications protocol message
        /// </summary>
        public static sealed class ChannelClearNotifications : OutboundMessage {
            ChannelClearNotifications(string channelUri, string type) {
                super("channelClearNotifications");
                
                put("channelUri", channelUri);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'postId' attribute on the message
            /// </summary>
            /// <param name="value">The post ID of channel notification. This field is mandatory when type is 'Post'.</param>
            /// <returns>this</returns>
            public ChannelClearNotifications postId(string value) {
                put("postId", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelCreate message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore creates an owned channel. When received, core will attempt 
        /// to create the channel as well as uploading the specified image. This is a long 
        /// running operation which requires communication to the BBM Channels 
        /// infrastructure. Core will immediately repond to this operation with a listAdd of 
        /// a channel URI on the localChannel list that references the Channel in its pending 
        /// state. Channel data can be fetched at anytime using the Channel map-only list. 
        /// </p>
        /// <p>
        /// 
        /// Once successfully created, the channel moves from a 'Pending' status to a 
        /// 'Created' status, there will be a URI change which will be issued by a listRemove 
        /// for the old URI followed by a listAdd for the new URI on the localChannel list. 
        /// </p>
        /// <p>
        /// 
        /// All responses will include the cookie, if set, of this request to allow the 
        /// requesting client to match the response with the request. Responses will be sent 
        /// to all clients to ensure data and state consistency. 
        /// </p>
        /// <p>
        /// 
        /// All well-formed requests will receive a response. If the requesting client 
        /// disconnects before a response is received, the result will be reflected either 
        /// the localChannel or channel lists upon reconnection. On success, the 
        /// localChannel list will contain the created channel. On failure, the channel list 
        /// will reflect the mostRecentError of the channel whose creation failed. 
        /// </p>
        /// </summary>
        /// <param name="categoryId"> The category this channel has been defined to belong to. It is a foreign key into channelCategory list. This is a mandatory field and should be defined when a channel is created.</param>
        /// <param name="chatEnabled">Iff this is true, then a subscriber may initiate a 1:1 conversation with the channel owner.</param>
        /// <param name="commentsEnabled">The Channel flag to allow comments on this channel</param>
        /// <param name="displayName">The display name of the channel.</param>
        /// <param name="imagePath">Using to indicate the full path name to the channel's associated image file (local to the device).  The image may or may not have an extension and the extension may not match the content type of the image file.</param>
        /// <param name="isPrivate">True iff the channel is private and subscription is by invitation only.</param>
        /// <param name="searchable">False iff the owner doesn't want this channel to appear in search results, or if isPrivate is true</param>
        /// <param name="showMap">Iff present and true, then a map should be shown on the channel's profile page using the information in the 'location' object.</param>
        public static ChannelCreate channelCreate(string categoryId, bool chatEnabled, bool commentsEnabled, string displayName, string imagePath, bool isPrivate, bool searchable, bool showMap) {
            return new ChannelCreate(categoryId, chatEnabled, commentsEnabled, displayName, imagePath, isPrivate, searchable, showMap);
        }

        /// <summary>
        /// This class represents an instance of the channelCreate protocol message
        /// </summary>
        public static sealed class ChannelCreate : OutboundMessage {
            ChannelCreate(string categoryId, bool chatEnabled, bool commentsEnabled, string displayName, string imagePath, bool isPrivate, bool searchable, bool showMap) {
                super("channelCreate");
                
                put("categoryId", categoryId);
                put("chatEnabled", chatEnabled);
                put("commentsEnabled", commentsEnabled);
                put("displayName", displayName);
                put("imagePath", imagePath);
                put("isPrivate", isPrivate);
                put("searchable", searchable);
                put("showMap", showMap);
            }

            /// <summary>
            /// Sets the optional 'additionalInfo' attribute on the message
            /// </summary>
            /// <param name="value">Additional description information for the channel.  Examples of content include business hours or just more detailed descriptions.</param>
            /// <returns>this</returns>
            public ChannelCreate additionalInfo(string value) {
                put("additionalInfo", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'contactEmailAddress' attribute on the message
            /// </summary>
            /// <param name="value">A contact email address for the channel.</param>
            /// <returns>this</returns>
            public ChannelCreate contactEmailAddress(string value) {
                put("contactEmailAddress", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">A cookie that will be referenced when reporting any errors or events associated with this request.</param>
            /// <returns>this</returns>
            public ChannelCreate cookie(string value) {
                put("cookie", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'customStatus' attribute on the message
            /// </summary>
            /// <param name="value">The status message for the channel, as updated from time to time by the owner, much like a contact's personal message.</param>
            /// <returns>this</returns>
            public ChannelCreate customStatus(string value) {
                put("customStatus", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'defaultInvitationMessage' attribute on the message
            /// </summary>
            /// <param name="value">The default message that is presented to potential new subscribers.</param>
            /// <returns>this</returns>
            public ChannelCreate defaultInvitationMessage(string value) {
                put("defaultInvitationMessage", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'description' attribute on the message
            /// </summary>
            /// <param name="value">The detailed description of the channel.</param>
            /// <returns>this</returns>
            public ChannelCreate description(string value) {
                put("description", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'location' attribute on the message
            /// </summary>
            /// <param name="value">The human readable location associated with the channel.</param>
            /// <returns>this</returns>
            public ChannelCreate location(JSONObject value) {
                put("location", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'moderationOn' attribute on the message
            /// </summary>
            /// <param name="value">Whether comment moderation by owner is on</param>
            /// <returns>this</returns>
            public ChannelCreate moderationOn(bool value) {
                put("moderationOn", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'phoneNumber' attribute on the message
            /// </summary>
            /// <param name="value">Phone number contact for the channel, in whatever form the channel owner entered it.</param>
            /// <returns>this</returns>
            public ChannelCreate phoneNumber(string value) {
                put("phoneNumber", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'subCategoryId' attribute on the message
            /// </summary>
            /// <param name="value">The subcategory related to the chosen main category that this channel has been defined to belong to. It is a foreign key into channelSubCategory list. If a subcategory list associated with the selected main category exists, client enforces selection of a subcategory.</param>
            /// <returns>this</returns>
            public ChannelCreate subCategoryId(string value) {
                put("subCategoryId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'webAddress' attribute on the message
            /// </summary>
            /// <param name="value">A URL to a web page associated with the channel.</param>
            /// <returns>this</returns>
            public ChannelCreate webAddress(string value) {
                put("webAddress", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'welcomeMessage' attribute on the message
            /// </summary>
            /// <param name="value">The channel welcome message that is displayed to new subscribers.</param>
            /// <returns>this</returns>
            public ChannelCreate welcomeMessage(string value) {
                put("welcomeMessage", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelFavourite message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore update the favourite flag of the subscription record of the 
        /// specified channel. 
        /// </p>
        /// <p>
        /// 
        /// If an error occurs, then a 'channelFavouriteError' message describing the error 
        /// is sent to the client that requested the subscription update. Receiving an error 
        /// does not preclude the subscription record being updated. 
        /// </p>
        /// <p>
        /// 
        /// If the user is not subscribed to the channel, that is considered to be an error. 
        /// </p>
        /// <p>
        /// 
        /// An owner cannot make his own channel a favourite. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel to update the subscription. The URI given must be unique across the entire BBM Channels infrastructure. Updating channels pending creation is not supported.</param>
        /// <param name="isFavourite">The channel flag indicating whether or not this channel is a favourite.</param>
        public static ChannelFavourite channelFavourite(string channelUri, bool isFavourite) {
            return new ChannelFavourite(channelUri, isFavourite);
        }

        /// <summary>
        /// This class represents an instance of the channelFavourite protocol message
        /// </summary>
        public static sealed class ChannelFavourite : OutboundMessage {
            ChannelFavourite(string channelUri, bool isFavourite) {
                super("channelFavourite");
                
                put("channelUri", channelUri);
                put("isFavourite", isFavourite);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelHideUpdate message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore update the hideUpdate flag of the specified channel. 
        /// Successful update should cause a listChange on the channel list. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel to update the subscription. The URI given must be unique across the entire BBM Channels infrastructure. Updating channels pending creation is not supported.</param>
        /// <param name="hideUpdate">The channel flag indicating whether or not this channel update should be hidden in recent update.</param>
        public static ChannelHideUpdate channelHideUpdate(string channelUri, bool hideUpdate) {
            return new ChannelHideUpdate(channelUri, hideUpdate);
        }

        /// <summary>
        /// This class represents an instance of the channelHideUpdate protocol message
        /// </summary>
        public static sealed class ChannelHideUpdate : OutboundMessage {
            ChannelHideUpdate(string channelUri, bool hideUpdate) {
                super("channelHideUpdate");
                
                put("channelUri", channelUri);
                put("hideUpdate", hideUpdate);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelIgnorePostCommentFlag message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This request can be sent to core by a channel owner. The UI sends this message to core 
        /// to notify that the channel owner would like to ignore the flag of a specific channel 
        /// post comment. The value of flag count attribute of the channel post comment is 
        /// greater than zero. The flagged comment will be removed from 
        /// flaggedChannelPostComment list but flag count will not be changed. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">Holds the unique identifier of the channel that the post which has the flagged comment belongs to. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure.</param>
        /// <param name="id">Holds the unique identifier of the flagged channel post comment.</param>
        /// <param name="postId">Holds the unique identifier of the channel post the flagged comment belongs to.</param>
        public static ChannelIgnorePostCommentFlag channelIgnorePostCommentFlag(string channelUri, string id, string postId) {
            return new ChannelIgnorePostCommentFlag(channelUri, id, postId);
        }

        /// <summary>
        /// This class represents an instance of the channelIgnorePostCommentFlag protocol message
        /// </summary>
        public static sealed class ChannelIgnorePostCommentFlag : OutboundMessage {
            ChannelIgnorePostCommentFlag(string channelUri, string id, string postId) {
                super("channelIgnorePostCommentFlag");
                
                put("channelUri", channelUri);
                put("id", id);
                put("postId", postId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelIgnorePostFlag message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This request can be sent to core by a channel owner. The UI sends this message to core 
        /// to notify that the channel owner would like to ignore the flag for a specific 
        /// channel post. The value of flag count attribute of the channel post comment is 
        /// greater than zero. The flagged post will be removed from flaggedChannelPost list 
        /// but flag count will not be changed. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that the post belongs to. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure.</param>
        /// <param name="id">Holds the unique identifier of the flagged channel post.</param>
        public static ChannelIgnorePostFlag channelIgnorePostFlag(string channelUri, string id) {
            return new ChannelIgnorePostFlag(channelUri, id);
        }

        /// <summary>
        /// This class represents an instance of the channelIgnorePostFlag protocol message
        /// </summary>
        public static sealed class ChannelIgnorePostFlag : OutboundMessage {
            ChannelIgnorePostFlag(string channelUri, string id) {
                super("channelIgnorePostFlag");
                
                put("channelUri", channelUri);
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelIgnoreRecommended message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core removes a recommended channel from the recommendedChannel 
        /// list. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the recommended channel that user has ignored. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure. Core removes this channel uri from the recommendedChannel list and replies with listRemove.</param>
        public static ChannelIgnoreRecommended channelIgnoreRecommended(string channelUri) {
            return new ChannelIgnoreRecommended(channelUri);
        }

        /// <summary>
        /// This class represents an instance of the channelIgnoreRecommended protocol message
        /// </summary>
        public static sealed class ChannelIgnoreRecommended : OutboundMessage {
            ChannelIgnoreRecommended(string channelUri) {
                super("channelIgnoreRecommended");
                
                put("channelUri", channelUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelInvitationAccept message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core accepts channel invitation request and subscribes invitee to 
        /// the channel. Modifies an element in listChannelInvitation that is currently in 
        /// the 'Pending' state. If the invitation does not exist or is not in the 'Pending' 
        /// state, core ignores the message. 
        /// </p>
        /// <p>
        /// 
        /// Core will notify the inviter. Core should reply to this message with a listChange 
        /// message that moves the invitation into 'Accepted' or 'Error' states. If core 
        /// can't proceed with subscribing the invitee invitation should be moved to 'Error' 
        /// state. 
        /// </p>
        /// <p>
        /// 
        /// Deprecated since 3.2 and it is replaced by channelSubscribe message. 
        /// </p>
        /// </summary>
        /// <param name="id">It is a foreign key into listChannelInvitation.</param>
        public static ChannelInvitationAccept channelInvitationAccept(string id) {
            return new ChannelInvitationAccept(id);
        }

        /// <summary>
        /// This class represents an instance of the channelInvitationAccept protocol message
        /// </summary>
        public static sealed class ChannelInvitationAccept : OutboundMessage {
            ChannelInvitationAccept(string id) {
                super("channelInvitationAccept");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelInvitationSend message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core sends a channel invitation message to a remote user. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that invitee might join. This must be a unique identifier across the BBM Channels infrastructure. Invitations to channels pending creation is not supported.</param>
        /// <param name="to">Contains user URIs, indicating the intended recipients of this invitation. When sent to a user (or multiple users), the invitation should be added to an existing 1-on-1 conversation with that user. See uriformats.txt for the URI format.</param>
        public static ChannelInvitationSend channelInvitationSend(string channelUri, List<string> to) {
            return new ChannelInvitationSend(channelUri, to);
        }

        /// <summary>
        /// This class represents an instance of the channelInvitationSend protocol message
        /// </summary>
        public static sealed class ChannelInvitationSend : OutboundMessage {
            ChannelInvitationSend(string channelUri, List<string> to) {
                super("channelInvitationSend");
                
                put("channelUri", channelUri);
                put("to", to);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">A cookie generated by UI that will be echoed back in the listAdd.</param>
            /// <returns>this</returns>
            public ChannelInvitationSend cookie(string value) {
                put("cookie", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'inviteMessage' attribute on the message
            /// </summary>
            /// <param name="value">Contains the inviter's customized message.</param>
            /// <returns>this</returns>
            public ChannelInvitationSend inviteMessage(string value) {
                put("inviteMessage", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkAsAcknowledged message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core updates the value of 'isNewPushedChannel' property of a 
        /// channel to false. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">Channel URI of the channel that user has just viewed and marked as acknowledged. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure.</param>
        public static ChannelMarkAsAcknowledged channelMarkAsAcknowledged(string channelUri) {
            return new ChannelMarkAsAcknowledged(channelUri);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkAsAcknowledged protocol message
        /// </summary>
        public static sealed class ChannelMarkAsAcknowledged : OutboundMessage {
            ChannelMarkAsAcknowledged(string channelUri) {
                super("channelMarkAsAcknowledged");
                
                put("channelUri", channelUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkAsRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core updates the value of 'hasNewPost' property of a channel to 
        /// false. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that user has just marked as read. The URI given must be unique across the entire BBM Channels infrastructure. Marking a channel as read is not supported for channels pending creation.</param>
        public static ChannelMarkAsRead channelMarkAsRead(string channelUri) {
            return new ChannelMarkAsRead(channelUri);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkAsRead protocol message
        /// </summary>
        public static sealed class ChannelMarkAsRead : OutboundMessage {
            ChannelMarkAsRead(string channelUri) {
                super("channelMarkAsRead");
                
                put("channelUri", channelUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkAsVisited message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core tags VISIT for the given channel on the hype server. As the 
        /// result, the number of times the channel is visited is increased by one. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that user has just marked as visited. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure. Marking a channel as visited is supported for channels that have been created successfully.</param>
        public static ChannelMarkAsVisited channelMarkAsVisited(string channelUri) {
            return new ChannelMarkAsVisited(channelUri);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkAsVisited protocol message
        /// </summary>
        public static sealed class ChannelMarkAsVisited : OutboundMessage {
            ChannelMarkAsVisited(string channelUri) {
                super("channelMarkAsVisited");
                
                put("channelUri", channelUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkNotificationAsReadById message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Marks a channel notification as read given its unique id. Core will respond with a 
        /// listChange message containing the updated channel notification. 
        /// </p>
        /// </summary>
        /// <param name="id">The unique id the channel notification to be marked as read.</param>
        public static ChannelMarkNotificationAsReadById channelMarkNotificationAsReadById(string id) {
            return new ChannelMarkNotificationAsReadById(id);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkNotificationAsReadById protocol message
        /// </summary>
        public static sealed class ChannelMarkNotificationAsReadById : OutboundMessage {
            ChannelMarkNotificationAsReadById(string id) {
                super("channelMarkNotificationAsReadById");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkNotificationsAsRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Marks all channel notifications as read up to and including the given timestamp. 
        /// Core should respond with a listAll message containing the updated channel 
        /// notifications. 
        /// </p>
        /// </summary>
        /// <param name="timestamp">The timestamp of the last channel notification to be marked as read.</param>
        public static ChannelMarkNotificationsAsRead channelMarkNotificationsAsRead(long timestamp) {
            return new ChannelMarkNotificationsAsRead(timestamp);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkNotificationsAsRead protocol message
        /// </summary>
        public static sealed class ChannelMarkNotificationsAsRead : OutboundMessage {
            ChannelMarkNotificationsAsRead(long timestamp) {
                super("channelMarkNotificationsAsRead");
                
                put("timestamp", Long.toString(timestamp));
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkPostAsHyped message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core hypes/unhypes a channel post. 
        /// </p>
        /// <p>
        /// 
        /// Core should reply to this message with a sparseChange message on the channelPost 
        /// that updates the 'hyped' field 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel containing the post to be hyped/unhyped.  This must be unique across the entire BBM Channels infrastructure. Posting on channels pending creation is not supported.</param>
        /// <param name="hype">Indicates if we are hyping the post.  A value of true indicates a 'hype'.  False indicates 'unhype'</param>
        /// <param name="postId">Identifies the post to hype/unhype</param>
        public static ChannelMarkPostAsHyped channelMarkPostAsHyped(string channelUri, bool hype, string postId) {
            return new ChannelMarkPostAsHyped(channelUri, hype, postId);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkPostAsHyped protocol message
        /// </summary>
        public static sealed class ChannelMarkPostAsHyped : OutboundMessage {
            ChannelMarkPostAsHyped(string channelUri, bool hype, string postId) {
                super("channelMarkPostAsHyped");
                
                put("channelUri", channelUri);
                put("hype", hype);
                put("postId", postId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelMarkPostsAsRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core increases the value of 'readCount' property of each post in the 
        /// list of channelPosts by 1. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that the list of post belongs to. The URI must be unique across the entire BBM Channels infrastructure. Posts to channesl that are pending creation is not supported.</param>
        /// <param name="ids">Ids of the channelPosts that user wants to mark as read.</param>
        public static ChannelMarkPostsAsRead channelMarkPostsAsRead(string channelUri, List<string> ids) {
            return new ChannelMarkPostsAsRead(channelUri, ids);
        }

        /// <summary>
        /// This class represents an instance of the channelMarkPostsAsRead protocol message
        /// </summary>
        public static sealed class ChannelMarkPostsAsRead : OutboundMessage {
            ChannelMarkPostsAsRead(string channelUri, List<string> ids) {
                super("channelMarkPostsAsRead");
                
                put("channelUri", channelUri);
                put("ids", ids);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelNotificationsEnabled message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore update the notificationsEnabled flag for the specified 
        /// channel. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel whose notifications will be suppressed by the service.</param>
        /// <param name="enabled">The channel flag indicating whether or not this channel's notifications will be suppressed by the service.</param>
        public static ChannelNotificationsEnabled channelNotificationsEnabled(string channelUri, bool enabled) {
            return new ChannelNotificationsEnabled(channelUri, enabled);
        }

        /// <summary>
        /// This class represents an instance of the channelNotificationsEnabled protocol message
        /// </summary>
        public static sealed class ChannelNotificationsEnabled : OutboundMessage {
            ChannelNotificationsEnabled(string channelUri, bool enabled) {
                super("channelNotificationsEnabled");
                
                put("channelUri", channelUri);
                put("enabled", enabled);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelRefreshStatsForPosts message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Request core to refresh statistics of the channel posts given an array of post IDs. 
        /// </p>
        /// <p>
        /// 
        /// Core will respond with sparseChange on channelPosts, listChange on 
        /// recentChannelPosts and listChange on post. 
        /// </p>
        /// </summary>
        /// <param name="ids">Ids of the channel posts for which we want to refresh the statistics.</param>
        public static ChannelRefreshStatsForPosts channelRefreshStatsForPosts(List<JSONObject> ids) {
            return new ChannelRefreshStatsForPosts(ids);
        }

        /// <summary>
        /// This class represents an instance of the channelRefreshStatsForPosts protocol message
        /// </summary>
        public static sealed class ChannelRefreshStatsForPosts : OutboundMessage {
            ChannelRefreshStatsForPosts(List<JSONObject> ids) {
                super("channelRefreshStatsForPosts");
                
                put("ids", ids);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelRemoveOwned message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore remove an owned channel. The owned channel to be removed is 
        /// identified by the channelUri. Removal is only supported for failed pending 
        /// channels or owned channels that have been successfully created (i.e. have a 
        /// status of Failed or Created). 
        /// </p>
        /// <p>
        /// 
        /// Requests to remove an unknown channelUri, no attempt to remove the channel from 
        /// the server will be made. A successful listRemove on the localChannel list will be 
        /// sent immediately to ensure clients and database remain in sync. 
        /// </p>
        /// <p>
        /// 
        /// Failed pending channels will be removed from the local database, no server 
        /// interaction is required, so the response will be immediate. 
        /// </p>
        /// <p>
        /// 
        /// Created owned channels must be removed from both the BBM Channels Server and the 
        /// local database, so the response can be delayed. 
        /// </p>
        /// <p>
        /// 
        /// Any failure to remove the channel will result in a listChange sent for the channel 
        /// being removed to set the mostRecentError. On successful removal of the channel, a 
        /// listRemove on the localChannel list will be sent. 
        /// </p>
        /// <p>
        /// 
        /// All responses will include the cookie, if set, of this request to allow the 
        /// requesting client to match the response with the request. Responses will be sent 
        /// to all clients to ensure data and state consistency. 
        /// </p>
        /// <p>
        /// 
        /// Requests that specify an invalid channelUri or a channel that is not owned by the 
        /// local user will be ignored and no response will be sent. Otherwise, all 
        /// well-formed requests will receive a response. If the requesting client 
        /// disconnects before a response is received, the result will be reflected either 
        /// the localChannel or channel lists upon reconnection. On success, the 
        /// localChannel list will not contain the removed channel. On failure, the channel 
        /// list will reflect the mostRecentError of the channel whose removal failed. 
        /// </p>
        /// <p>
        /// 
        /// Removal from the channel list is not supported. When the removal of a Created 
        /// channel occurs, the channel will be transitioned to a Remote channel to ensure 
        /// that other lists referencing this channel retain their data and the current 
        /// status of the channel correctly reflected. The only exception to this is when the 
        /// channel being removed is not found. No transitioning will occur in this instance. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the owned channel to be removed.  The URI given must uniquely identify the channel locally when removing a Failed channel.  The URI must uniquely identify the channel across the entire BBM Channels infrastructure when removing a Created channel.</param>
        public static ChannelRemoveOwned channelRemoveOwned(string channelUri) {
            return new ChannelRemoveOwned(channelUri);
        }

        /// <summary>
        /// This class represents an instance of the channelRemoveOwned protocol message
        /// </summary>
        public static sealed class ChannelRemoveOwned : OutboundMessage {
            ChannelRemoveOwned(string channelUri) {
                super("channelRemoveOwned");
                
                put("channelUri", channelUri);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">A cookie that will be referenced when reporting any errors or events associated with this request.</param>
            /// <returns>this</returns>
            public ChannelRemoveOwned cookie(string value) {
                put("cookie", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelSubscribe message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore subscribe the local user to the specified BBM Channel. 
        /// </p>
        /// <p>
        /// 
        /// If an error occurs, then a 'channelSubscribeError' message describing the error 
        /// is sent to the client that requested the subscription with a copy of the cookie 
        /// provided in the request. Receiving an error does not preclude the user ending up 
        /// subscribed to the channel. 
        /// </p>
        /// <p>
        /// 
        /// If the user is already subscribed to the channel, that is considered to be an error. 
        /// </p>
        /// <p>
        /// 
        /// When a new channel is created, bbmcore sends a 'listAdd' containing the new 
        /// channel. The 'listAdd' contains the cookie. 
        /// </p>
        /// <p>
        /// 
        /// A response is guaranteed for every well-formed 'channelSubscribe' message, 
        /// either in the form of a 'listAdd' or a 'channelSubscribeError' up until such time 
        /// as the PPS connectivity between the endpoints is lost. Responses may be delivered 
        /// after PPS connectivity is re-established, but this is not guaranteed. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel to which the user would like to subscribe. The URI given must be unique across the entire BBM Channels infrastructure. Subscribing to channels pending creation is not supported.</param>
        /// <param name="reason">Indicates how the device is subscribing to this channel.</param>
        public static ChannelSubscribe channelSubscribe(string channelUri, string reason) {
            return new ChannelSubscribe(channelUri, reason);
        }

        /// <summary>
        /// This class represents an instance of the channelSubscribe protocol message
        /// </summary>
        public static sealed class ChannelSubscribe : OutboundMessage {
            ChannelSubscribe(string channelUri, string reason) {
                super("channelSubscribe");
                
                put("channelUri", channelUri);
                put("reason", reason);
            }

            /// <summary>
            /// Sets the optional 'ad' attribute on the message
            /// </summary>
            /// <param name="value">Required only if reason is of type Ad. Holds the necessary ad information for the service to subscribe to a channel advertised via an advertisement.</param>
            /// <returns>this</returns>
            public ChannelSubscribe ad(JSONObject value) {
                put("ad", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">A cookie that will be referenced when reporting any errors or events associated with this request.</param>
            /// <returns>this</returns>
            public ChannelSubscribe cookie(string value) {
                put("cookie", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'minAge' attribute on the message
            /// </summary>
            /// <param name="value">The min age allowed for the channel. If this field doesn't exists, it means that there is no min age restriction for the channel. Core only uses the provided minAge for verification if it can't find the channel data in its local cache.</param>
            /// <returns>this</returns>
            public ChannelSubscribe minAge(long value) {
                put("minAge", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ChannelUnsubscribe message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore unsubscribe the local user to the specified BBM Channel. 
        /// </p>
        /// <p>
        /// 
        /// If an error occurs, then a 'channelUnsubscribeError' message describing the 
        /// error is sent to the client that requested the subscription with a copy of the 
        /// cookie provided in the request. Receiving an error does not perclude the user 
        /// ending up unsubscribed from the channel. 
        /// </p>
        /// <p>
        /// 
        /// If the user is already unsubscribed from the channel, that is considered to be an 
        /// error. 
        /// </p>
        /// <p>
        /// 
        /// When the unsubscription results in the user no longer being related to the 
        /// channel, bbmcore sends a 'listRemove' for the channel. If the unsubscription 
        /// succeeds, but does not result in the user no longer being related to the channel, 
        /// bbmcore sends a list update ('listElements' or 'listChange') for the channel to 
        /// reflect the new status. The cookie will be present in whatever list update message 
        /// may result. 
        /// </p>
        /// <p>
        /// 
        /// A response is guaranteed for every well-formed 'channelUnsubscribe' message, 
        /// either in the form of a list change notification or a 'channelUnsubscribeError' 
        /// up until such time as the PPS connectivity between the endpoints is lost. 
        /// Responses may be delivered after PPS connectivity is re-established, but this is 
        /// not guaranteed. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel to which the user would like to unsubscribe.  The URI given must be unique across the entire BBM Channels infrastructure.  Unsubscribing to channels pending creation is not supported.</param>
        public static ChannelUnsubscribe channelUnsubscribe(string channelUri) {
            return new ChannelUnsubscribe(channelUri);
        }

        /// <summary>
        /// This class represents an instance of the channelUnsubscribe protocol message
        /// </summary>
        public static sealed class ChannelUnsubscribe : OutboundMessage {
            ChannelUnsubscribe(string channelUri) {
                super("channelUnsubscribe");
                
                put("channelUri", channelUri);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">A cookie that will be referenced when reporting any errors or events associated with this request.</param>
            /// <returns>this</returns>
            public ChannelUnsubscribe cookie(string value) {
                put("cookie", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ClearMessageHistory message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Permanently deletes the entire message history for all conversations whose URIs 
        /// are given in the conversationUris field. If the conversationUris field is 
        /// omitted all existing conversations' message histories will be deleted, 
        /// including message histories being kept for conversations that have ended. 
        /// </p>
        /// <p>
        /// 
        /// Core will send out conversation listChange messages for all affected existing 
        /// conversations indicating that the message histories are now empty. 
        /// </p>
        /// </summary>
        public static ClearMessageHistory clearMessageHistory() {
            return new ClearMessageHistory();
        }

        /// <summary>
        /// This class represents an instance of the clearMessageHistory protocol message
        /// </summary>
        public static sealed class ClearMessageHistory : OutboundMessage {
            ClearMessageHistory() {
                super("clearMessageHistory");
                
            }

            /// <summary>
            /// Sets the optional 'conversationUris' attribute on the message
            /// </summary>
            /// <param name="value">Holds the URIs of the conversations to be cleared; omit this field entirely to clear all conversations.</param>
            /// <returns>this</returns>
            public ClearMessageHistory conversationUris(List<string> value) {
                put("conversationUris", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ClearRecentUpdates message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Clears all recent updates up to and including the given recent update id. Core 
        /// should respond with a listAll message containing any remaining messages. 
        /// </p>
        /// </summary>
        /// <param name="id">The id of the last recent update to remove.</param>
        public static ClearRecentUpdates clearRecentUpdates(string id) {
            return new ClearRecentUpdates(id);
        }

        /// <summary>
        /// This class represents an instance of the clearRecentUpdates protocol message
        /// </summary>
        public static sealed class ClearRecentUpdates : OutboundMessage {
            ClearRecentUpdates(string id) {
                super("clearRecentUpdates");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ClearSystemNotifications message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Request that core clear all BBM system notifications (i.e. "clear the home screen 
        /// splat and blinking LED"). This is unconditional. 
        /// </p>
        /// </summary>
        public static ClearSystemNotifications clearSystemNotifications() {
            return new ClearSystemNotifications();
        }

        /// <summary>
        /// This class represents an instance of the clearSystemNotifications protocol message
        /// </summary>
        public static sealed class ClearSystemNotifications : OutboundMessage {
            ClearSystemNotifications() {
                super("clearSystemNotifications");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ConferenceInvitationResponse message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Used by the UI to acknowledge an incoming conference invitation request. Core 
        /// responds by removing the element from the listConferenceInvitation list via a 
        /// listRemove message and by sending the acknowledgement to the remote device 
        /// </p>
        /// </summary>
        /// <param name="requestId">Identifies the invitation to which this response applies</param>
        public static ConferenceInvitationResponse conferenceInvitationResponse(string requestId) {
            return new ConferenceInvitationResponse(requestId);
        }

        /// <summary>
        /// This class represents an instance of the conferenceInvitationResponse protocol message
        /// </summary>
        public static sealed class ConferenceInvitationResponse : OutboundMessage {
            ConferenceInvitationResponse(string requestId) {
                super("conferenceInvitationResponse");
                
                put("requestId", requestId);
            }

            /// <summary>
            /// Sets the optional 'response' attribute on the message
            /// </summary>
            /// <param name="value">Response to the invitation request</param>
            /// <returns>this</returns>
            public ConferenceInvitationResponse response(string value) {
                put("response", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ContactEmailInvitation message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Sent from the UI to core to request that an email be sent inviting the recipient to 
        /// join the user's contact list. Core usually responds by sending the invitation and 
        /// adding an entry to the pendingContact list using a listAdd message. 
        /// </p>
        /// </summary>
        /// <param name="accountId">The identifier of the local user's PIM account from which the email invitation should be sent from.</param>
        /// <param name="greeting">The greeting to be included in the email invitation and presented to the user within BBM.</param>
        /// <param name="localAddress">The email address of the local user's PIM account from which the email invitation should be sent from. This is also required along with the accountId because it must be included within the final invite accept message that is sent via RIM_IM.</param>
        /// <param name="remoteAddress">The invitation recipient's email address.</param>
        /// <param name="subject">The subject to be included in the email invitation. This is not used to process the invitation. And would only be presented if the email recipient does not have BBM on the device receiving the email invitation.</param>
        public static ContactEmailInvitation contactEmailInvitation(long accountId, string greeting, string localAddress, string remoteAddress, string subject) {
            return new ContactEmailInvitation(accountId, greeting, localAddress, remoteAddress, subject);
        }

        /// <summary>
        /// This class represents an instance of the contactEmailInvitation protocol message
        /// </summary>
        public static sealed class ContactEmailInvitation : OutboundMessage {
            ContactEmailInvitation(long accountId, string greeting, string localAddress, string remoteAddress, string subject) {
                super("contactEmailInvitation");
                
                put("accountId", accountId);
                put("greeting", greeting);
                put("localAddress", localAddress);
                put("remoteAddress", remoteAddress);
                put("subject", subject);
            }

            /// <summary>
            /// Sets the optional 'categoryId' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the UI's preferred category into which the newly added contact should be added. Omitted if the UI has not yet requested any particular category for the contact. If omitted or invalid at the time the contact is added to the contact list, it will added to the default category.</param>
            /// <returns>this</returns>
            public ContactEmailInvitation categoryId(long value) {
                put("categoryId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'nickname' attribute on the message
            /// </summary>
            /// <param name="value">Holds the nickname to be used for the invited user. If present, the given nickname will be used for the user both when they appear in the pending invitations table and, if the invitation is accepted, when they appear in the contacts table.</param>
            /// <returns>this</returns>
            public ContactEmailInvitation nickname(string value) {
                put("nickname", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'securityAnswer' attribute on the message
            /// </summary>
            /// <param name="value">The Expected answer to the security question. This is required if and only if the securityQuestion is included.</param>
            /// <returns>this</returns>
            public ContactEmailInvitation securityAnswer(string value) {
                put("securityAnswer", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'securityQuestion' attribute on the message
            /// </summary>
            /// <param name="value">The user-readable security question. If omitted, there is no security question.</param>
            /// <returns>this</returns>
            public ContactEmailInvitation securityQuestion(string value) {
                put("securityQuestion", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ContactInvitation message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Sent from the UI to core to request that a contact be invited to the contact list. 
        /// Core usually responds by sending the invitation to the remote user and adding an 
        /// entry to the pendingContact list using a listAdd message. In the case of QR code 
        /// invitation, the invite greeting must be prefixed by a plain text with the 
        /// following format bbm:&lt;hash&gt;&lt;pin&gt;&ltdisplayName&gt;. The hash 
        /// value is obtained from the scanned QR code. 
        /// </p>
        /// </summary>
        public static ContactInvitation contactInvitation() {
            return new ContactInvitation();
        }

        /// <summary>
        /// This class represents an instance of the contactInvitation protocol message
        /// </summary>
        public static sealed class ContactInvitation : OutboundMessage {
            ContactInvitation() {
                super("contactInvitation");
                
            }

            /// <summary>
            /// Sets the optional 'categoryId' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the UI's preferred category into which the newly added contact should be added. Omitted if the UI has not yet requested any particular category for the contact. If omitted or invalid at the time the contact is added to the contact list, it will added to the default category.</param>
            /// <returns>this</returns>
            public ContactInvitation categoryId(long value) {
                put("categoryId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'displayName' attribute on the message
            /// </summary>
            /// <param name="value">Holds the displayName to be used for the invited user. If present, the given displayName will be used for the user only when they appear in the pending invitations table. This is expected to be overwritten by the contact's current display name once the invitation is accepted.</param>
            /// <returns>this</returns>
            public ContactInvitation displayName(string value) {
                put("displayName", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'ecoId' attribute on the message
            /// </summary>
            /// <param name="value">Holds the non-empty BBID ecoId of the contact to be invited. This will first be resolved to a set of device PINs by querying the BBID service. The invitation will then be sent to all resolved PINs. Either this or a contact's PIN must be provided.</param>
            /// <returns>this</returns>
            public ContactInvitation ecoId(string value) {
                put("ecoId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'greeting' attribute on the message
            /// </summary>
            /// <param name="value">Holds the user-readable message associated with the invitation, in the language of the sender. Displayed verbatim. In the case of QR code invitation, the greeting must be prefixed by a plain text with the following format bbm:&lt;hash&gt;&lt;pin&gt;&ltdisplayName&gt;.</param>
            /// <returns>this</returns>
            public ContactInvitation greeting(string value) {
                put("greeting", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'nickname' attribute on the message
            /// </summary>
            /// <param name="value">Holds the nickname to be used for the invited user. If present, the given nickname will be used for the user both when they appear in the pending invitations table and, if the invitation is accepted, when they appear in the contacts table.</param>
            /// <returns>this</returns>
            public ContactInvitation nickname(string value) {
                put("nickname", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'pin' attribute on the message
            /// </summary>
            /// <param name="value">Holds the device PIN of the contact to be invited, as a 8-character lowercase hex string. Either this or a contact's BBID ecoId must be set.</param>
            /// <returns>this</returns>
            public ContactInvitation pin(string value) {
                put("pin", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'securityAnswer' attribute on the message
            /// </summary>
            /// <param name="value">Expected answer to the security question. This is required if and only if the securityQuestion is included.</param>
            /// <returns>this</returns>
            public ContactInvitation securityAnswer(string value) {
                put("securityAnswer", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'securityQuestion' attribute on the message
            /// </summary>
            /// <param name="value">User-readable security question. If omitted, there is no security question.</param>
            /// <returns>this</returns>
            public ContactInvitation securityQuestion(string value) {
                put("securityQuestion", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ContactInvitationAccept message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Used to accept invitations from the pendingContact list. Core will notify the 
        /// remote user of the response and change the pending contact into the 'Accepted' 
        /// state using a listChange. Once core has confirmed that the remote user has 
        /// received the acceptance, it will remove the element from the pendingContact list 
        /// using a listRemove message, add the new contact using a listAdd in the contact 
        /// list, and notify the UI of the user's metadata using a listElements message in the 
        /// user list. Core will also send a listAdd in the relevant categoryContents list 
        /// </p>
        /// </summary>
        /// <param name="id">Identifies the element in the pendingContact list that this ID applies to</param>
        public static ContactInvitationAccept contactInvitationAccept(string id) {
            return new ContactInvitationAccept(id);
        }

        /// <summary>
        /// This class represents an instance of the contactInvitationAccept protocol message
        /// </summary>
        public static sealed class ContactInvitationAccept : OutboundMessage {
            ContactInvitationAccept(string id) {
                super("contactInvitationAccept");
                
                put("id", id);
            }

            /// <summary>
            /// Sets the optional 'categoryId' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the category into which the newly added contact should be added. If omitted, the contact will be added to the default category. This is a foreign key into listCategory.</param>
            /// <returns>this</returns>
            public ContactInvitationAccept categoryId(long value) {
                put("categoryId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'securityAnswer' attribute on the message
            /// </summary>
            /// <param name="value">Contains the response to the security question, if any. Omitted if there is no security question.</param>
            /// <returns>this</returns>
            public ContactInvitationAccept securityAnswer(string value) {
                put("securityAnswer", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ContactInvitationDelete message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Used to decline invitations from the pendingContact list. Depending on the 
        /// response, core will normally notify the remote user of the response and delete the 
        /// pending contact from the pendingContact list using a listRemove message. If 
        /// 'ignore' is true, core will respond with a listAdd to the userBlockedItem list. 
        /// </p>
        /// </summary>
        /// <param name="id">Identifies the element in the pendingContact list that this ID applies to</param>
        /// <param name="ignore">If true, indicates that future invitations from this sender should be automatically ignored (via the userBlockedItem list). The default value is false.</param>
        /// <param name="sendResponse">Indicates whether or not the remote party should be notified about the declined invitation. If false, the invitation is declined silently. The default value is false.</param>
        public static ContactInvitationDelete contactInvitationDelete(string id, bool ignore, bool sendResponse) {
            return new ContactInvitationDelete(id, ignore, sendResponse);
        }

        /// <summary>
        /// This class represents an instance of the contactInvitationDelete protocol message
        /// </summary>
        public static sealed class ContactInvitationDelete : OutboundMessage {
            ContactInvitationDelete(string id, bool ignore, bool sendResponse) {
                super("contactInvitationDelete");
                
                put("id", id);
                put("ignore", ignore);
                put("sendResponse", sendResponse);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ContactPickerChoiceSelected message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core accept the picked contacts for a particular contact picker 
        /// corresponding to tpaUri. 
        /// </p>
        /// <p>
        /// 
        /// Core should not reply to this message. Instead it carries out the function 
        /// intended with the picked contacts corresponding to the payload given in the 
        /// initial requestPicker; as well, it removes its own internal references to this 
        /// contact picker session. 
        /// </p>
        /// </summary>
        /// <param name="tpaUri">This is a foreign key into listTpa.</param>
        public static ContactPickerChoiceSelected contactPickerChoiceSelected(string tpaUri) {
            return new ContactPickerChoiceSelected(tpaUri);
        }

        /// <summary>
        /// This class represents an instance of the contactPickerChoiceSelected protocol message
        /// </summary>
        public static sealed class ContactPickerChoiceSelected : OutboundMessage {
            ContactPickerChoiceSelected(string tpaUri) {
                super("contactPickerChoiceSelected");
                
                put("tpaUri", tpaUri);
            }

            /// <summary>
            /// Sets the optional 'cancelled' attribute on the message
            /// </summary>
            /// <param name="value">Indicates whether the picker was cancelled by the user. If true, core should remove its internal references to this contact picker session. The default value is false.</param>
            /// <returns>this</returns>
            public ContactPickerChoiceSelected cancelled(bool value) {
                put("cancelled", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'choices' attribute on the message
            /// </summary>
            /// <param name="value">These choices are foreign keys into listUser. This attribute is required when there are users selected in the contact picker referenced by gid. This attribute is not required when cancelled is true.</param>
            /// <returns>this</returns>
            public ContactPickerChoiceSelected choices(List<string> value) {
                put("choices", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'customMessage' attribute on the message
            /// </summary>
            /// <param name="value">An optional custom message that can be prepared with picker selections. e.g. to display on the receiver's end of an invite.</param>
            /// <returns>this</returns>
            public ContactPickerChoiceSelected customMessage(string value) {
                put("customMessage", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ContactRemove message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core remove a contact from the contact list. Core will respond with a 
        /// listRemove in the contact list, optionally a listAdd in the userBlockedItem 
        /// list, and possibly other messages (such as listRemove, listChange, or 
        /// listElements) if the contact's URI is referenced in other lists. Although the 
        /// exact sequence of messages sent by core to the UI is not constrained by this 
        /// protocol, core is required to notify the UI of all indirect changes caused by the 
        /// contact removal. 
        /// </p>
        /// </summary>
        /// <param name="uri">URI of the contact to remove.</param>
        public static ContactRemove contactRemove(string uri) {
            return new ContactRemove(uri);
        }

        /// <summary>
        /// This class represents an instance of the contactRemove protocol message
        /// </summary>
        public static sealed class ContactRemove : OutboundMessage {
            ContactRemove(string uri) {
                super("contactRemove");
                
                put("uri", uri);
            }

            /// <summary>
            /// Sets the optional 'ignore' attribute on the message
            /// </summary>
            /// <param name="value">If true, indicates that future invitations from this contact should be automatically ignored (via the userBlockedItem list). The default value is false.</param>
            /// <returns>this</returns>
            public ContactRemove ignore(bool value) {
                put("ignore", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new FileTransferAccept message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core accept a file transfer request and optionally changes the path 
        /// to which the file will be downloaded. Modifies an element in listFileTransfer 
        /// that is currently in the 'Request' state. If the transfer does not exist or is not in 
        /// the 'Request' state, core ignores the message. 
        /// </p>
        /// <p>
        /// 
        /// Core should reply to this message with a listChange message that moves the file 
        /// into either the 'Progressing' or the 'Aborted' states, based on whether core is 
        /// able to proceed with the transfer. 
        /// </p>
        /// </summary>
        /// <param name="id"> ID of the transfer to accept.</param>
        /// <param name="path">Holds an absolute path to use for the received file.  This cannot be the empty string.  Core may restrict the path name in various ways for security reasons.  For example, there may be a whitelist that the directory portion of the path must match.  Requests that fail such security checks will lead to a failure of the transfer.</param>
        public static FileTransferAccept fileTransferAccept(string id, string path) {
            return new FileTransferAccept(id, path);
        }

        /// <summary>
        /// This class represents an instance of the fileTransferAccept protocol message
        /// </summary>
        public static sealed class FileTransferAccept : OutboundMessage {
            FileTransferAccept(string id, string path) {
                super("fileTransferAccept");
                
                put("id", id);
                put("path", path);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new FileTransferCancel message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core cancels a file transfer if it is in progress, and deletes any 
        /// portion of the file that has already been downloaded. The file is put in the error 
        /// state with an appropriate error message indicating user cancellation. This is a 
        /// no-op when invoked on files that are already in the error state. 
        /// </p>
        /// </summary>
        /// <param name="id">ID of the transfer to which this action applies.</param>
        public static FileTransferCancel fileTransferCancel(string id) {
            return new FileTransferCancel(id);
        }

        /// <summary>
        /// This class represents an instance of the fileTransferCancel protocol message
        /// </summary>
        public static sealed class FileTransferCancel : OutboundMessage {
            FileTransferCancel(string id) {
                super("fileTransferCancel");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new FileTransferSend message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core sends a file to a remote user. Based on the file's mime type, this 
        /// may result in either a new picture transfer or a new file transfer. 
        /// </p>
        /// </summary>
        /// <param name="description">Contains the user-readable (untranslatable) description filled in by the local user. Possibly empty.</param>
        /// <param name="path">Path to the file on the local filesystem.</param>
        /// <param name="to">Contains any combination of user and conversation URIs, indicating the intended recipients of this file. If the message is addressed to a user (or multiple users), it should be added to an existing 1-on-1 conversation with that user. If no such conversation exists yet, the individual URI will be ignored by core. If the conversation exists (and is either a multi-chat or 1-on-1 chat), it is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        public static FileTransferSend fileTransferSend(string description, string path, List<string> to) {
            return new FileTransferSend(description, path, to);
        }

        /// <summary>
        /// This class represents an instance of the fileTransferSend protocol message
        /// </summary>
        public static sealed class FileTransferSend : OutboundMessage {
            FileTransferSend(string description, string path, List<string> to) {
                super("fileTransferSend");
                
                put("description", description);
                put("path", path);
                put("to", to);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new FlagChannel message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify that the user would like to flag a 
        /// specific channel as inappropriate. The user cannot flag a channel that they own. 
        /// </p>
        /// </summary>
        /// <param name="uri">Holds the unique identifier of the channel that the user is trying to flag.</param>
        public static FlagChannel flagChannel(string uri) {
            return new FlagChannel(uri);
        }

        /// <summary>
        /// This class represents an instance of the flagChannel protocol message
        /// </summary>
        public static sealed class FlagChannel : OutboundMessage {
            FlagChannel(string uri) {
                super("flagChannel");
                
                put("uri", uri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new FlagChannelPost message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify that the user would like to flag a 
        /// specific channel post as inappropriate. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that the post belongs to. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure.</param>
        /// <param name="id">Holds the unique identifier of the channel post to flag.</param>
        public static FlagChannelPost flagChannelPost(string channelUri, string id) {
            return new FlagChannelPost(channelUri, id);
        }

        /// <summary>
        /// This class represents an instance of the flagChannelPost protocol message
        /// </summary>
        public static sealed class FlagChannelPost : OutboundMessage {
            FlagChannelPost(string channelUri, string id) {
                super("flagChannelPost");
                
                put("channelUri", channelUri);
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new FlagChannelPostComment message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify that the user would like to flag a 
        /// specific channel post comment as inappropriate. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">Holds the unique identifier of the channel that the post to flag belongs to.</param>
        /// <param name="id">Holds the unique identifier of the channel post comment to flag.</param>
        /// <param name="postId">Holds the unique identifier of the channel post the comment belongs to.</param>
        public static FlagChannelPostComment flagChannelPostComment(string channelUri, string id, string postId) {
            return new FlagChannelPostComment(channelUri, id, postId);
        }

        /// <summary>
        /// This class represents an instance of the flagChannelPostComment protocol message
        /// </summary>
        public static sealed class FlagChannelPostComment : OutboundMessage {
            FlagChannelPostComment(string channelUri, string id, string postId) {
                super("flagChannelPostComment");
                
                put("channelUri", channelUri);
                put("id", id);
                put("postId", postId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new InviteToConference message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Invites one or more additional participants to an existing or new conversation. 
        /// In the case of an existing conversation, core needs to deal with four cases, based 
        /// on whether the local user is the owner of the conversation and whether or not the 
        /// conversation is already a conference. If the local user is not the owner, a request 
        /// is made of the conversation owner to convert to a conference and/or invite the new 
        /// participants. If the local user is the owner, the new participants are invited 
        /// immediately. 
        /// </p>
        /// <p>
        /// 
        /// If the conversation is not yet a conference, it will be converted into a 
        /// conference. Core will notify the UI that this has occurred using a listChange 
        /// event on the conversation list. In the event that the user was not the owner of the 
        /// conference, this notification will only happen after the remote user has 
        /// confirmed the request 
        /// </p>
        /// <p>
        /// 
        /// This message cannot be used to start new conversations. 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">URI of a conversation. If this points to a 1-on-1 conversation, this message essentially becomes a request to convert that conversation to a conference</param>
        /// <param name="invitees">Holds the list of new invitees to the conference. If the list is empty, this remains a request to convert the conversation to a conference (if it is not already one) although no new participants will be added.</param>
        public static InviteToConference inviteToConference(string conversationUri, List<string> invitees) {
            return new InviteToConference(conversationUri, invitees);
        }

        /// <summary>
        /// This class represents an instance of the inviteToConference protocol message
        /// </summary>
        public static sealed class InviteToConference : OutboundMessage {
            InviteToConference(string conversationUri, List<string> invitees) {
                super("inviteToConference");
                
                put("conversationUri", conversationUri);
                put("invitees", invitees);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new LocationSend message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core sends a location to remote user(s). 
        /// </p>
        /// </summary>
        /// <param name="to">Contains any combination of user and conversation URIs, indicating the intended recipients of this location. If the message is addressed to a user (or multiple users), it should be added to an existing 1-on-1 conversation with that user. If no such conversation exists yet, the individual URI will be ignored by core. If the conversation exists (and is either a multi-chat or 1-on-1 chat), it is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        /// <param name="uiId">Unique identifier for this location as generated by the UI.</param>
        public static LocationSend locationSend(List<string> to, string uiId) {
            return new LocationSend(to, uiId);
        }

        /// <summary>
        /// This class represents an instance of the locationSend protocol message
        /// </summary>
        public static sealed class LocationSend : OutboundMessage {
            LocationSend(List<string> to, string uiId) {
                super("locationSend");
                
                put("to", to);
                put("uiId", uiId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new MarkChannelConversationRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Marks a channelConversation as read. Core should respond with a listChange 
        /// message containing the updated channelConversation. 
        /// </p>
        /// </summary>
        /// <param name="id">The id of the channelConversation to mark as read.</param>
        public static MarkChannelConversationRead markChannelConversationRead(string id) {
            return new MarkChannelConversationRead(id);
        }

        /// <summary>
        /// This class represents an instance of the markChannelConversationRead protocol message
        /// </summary>
        public static sealed class MarkChannelConversationRead : OutboundMessage {
            MarkChannelConversationRead(string id) {
                super("markChannelConversationRead");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new MarkRecentUpdatesRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Marks all recent updates as read up to and including the given recent update id. 
        /// Core should respond with a listAll message containing the updated recent 
        /// updates. 
        /// </p>
        /// </summary>
        /// <param name="id">The id of the last recent update to mark as read.</param>
        public static MarkRecentUpdatesRead markRecentUpdatesRead(string id) {
            return new MarkRecentUpdatesRead(id);
        }

        /// <summary>
        /// This class represents an instance of the markRecentUpdatesRead protocol message
        /// </summary>
        public static sealed class MarkRecentUpdatesRead : OutboundMessage {
            MarkRecentUpdatesRead(string id) {
                super("markRecentUpdatesRead");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new MessageStatus message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify it that an incoming message has been read 
        /// by the local user. 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">Holds the URI of the conversation to which this message applies</param>
        /// <param name="id">Holds the unique identifier of the newly read message. This is an integer which, combined with the conversation ID, is a foreign key into listMessage.</param>
        /// <param name="status">Holds the new status for the message. Currently only the Read status is supported.</param>
        public static MessageStatus messageStatus(string conversationUri, long id, string status) {
            return new MessageStatus(conversationUri, id, status);
        }

        /// <summary>
        /// This class represents an instance of the messageStatus protocol message
        /// </summary>
        public static sealed class MessageStatus : OutboundMessage {
            MessageStatus(string conversationUri, long id, string status) {
                super("messageStatus");
                
                put("conversationUri", conversationUri);
                put("id", Long.toString(id));
                put("status", status);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new NfcInviteCancelled message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to notify core that the NFC Invitation has been 
        /// cancelled. This will prompt core to remove the Invite from the database. There is 
        /// no response to this message. 
        /// </p>
        /// </summary>
        /// <param name="id">The identifier for the invite in the database</param>
        public static NfcInviteCancelled nfcInviteCancelled(string id) {
            return new NfcInviteCancelled(id);
        }

        /// <summary>
        /// This class represents an instance of the nfcInviteCancelled protocol message
        /// </summary>
        public static sealed class NfcInviteCancelled : OutboundMessage {
            NfcInviteCancelled(string id) {
                super("nfcInviteCancelled");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new NfcInviteCreate message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to request an Invite be created and returned to the 
        /// UI for delivery to the target via NFC. 
        /// </p>
        /// <p>
        /// 
        /// The invite returned will be recorded in the database, however no listAdd for the 
        /// pendingContact will be sent. This message will trigger a "nfcInvite" message 
        /// response. 
        /// </p>
        /// </summary>
        public static NfcInviteCreate nfcInviteCreate() {
            return new NfcInviteCreate();
        }

        /// <summary>
        /// This class represents an instance of the nfcInviteCreate protocol message
        /// </summary>
        public static sealed class NfcInviteCreate : OutboundMessage {
            NfcInviteCreate() {
                super("nfcInviteCreate");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new NfcInviteReceived message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to notify core that an Invitation has been received via 
        /// NFC. This will prompt core to record the Invitation in the database and accept the 
        /// invite iff the autoAccept flag has been set. 
        /// </p>
        /// <p>
        /// 
        /// This will trigger a response of a listAdd for a PendingContact. 
        /// </p>
        /// </summary>
        /// <param name="autoAccept">Flag indicating whether or not the invite should be automatically accepted or not.</param>
        /// <param name="invite">The Base64 encoded string representing the Invite that was received via NFC.</param>
        public static NfcInviteReceived nfcInviteReceived(bool autoAccept, string invite) {
            return new NfcInviteReceived(autoAccept, invite);
        }

        /// <summary>
        /// This class represents an instance of the nfcInviteReceived protocol message
        /// </summary>
        public static sealed class NfcInviteReceived : OutboundMessage {
            NfcInviteReceived(bool autoAccept, string invite) {
                super("nfcInviteReceived");
                
                put("autoAccept", autoAccept);
                put("invite", invite);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new NfcInviteSent message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to notify core that the NFC Invitation has been sent. The 
        /// response to this message will be a listAdd for a PendingContact. 
        /// </p>
        /// </summary>
        /// <param name="id">The identifier for the invite in the database</param>
        public static NfcInviteSent nfcInviteSent(string id) {
            return new NfcInviteSent(id);
        }

        /// <summary>
        /// This class represents an instance of the nfcInviteSent protocol message
        /// </summary>
        public static sealed class NfcInviteSent : OutboundMessage {
            NfcInviteSent(string id) {
                super("nfcInviteSent");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new NowPlayingState message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This is intended for non-BB10 clients where core does not have a PPS stream for 
        /// media updates. It enables the UI to notify the core of change in the state of the 
        /// current media being played. If this is received when there is no current media the 
        /// state will not be processed until core receives a nowPlayingUpdate message with 
        /// the track information. The UI should send this message whenever the playing state 
        /// changes. Core will not respond directly to this message, but there may be updates 
        /// through a change in the nowPlayingMessage to the UI. 
        /// </p>
        /// </summary>
        /// <param name="state">Notify core of the current media state. </param>
        public static NowPlayingState nowPlayingState(string state) {
            return new NowPlayingState(state);
        }

        /// <summary>
        /// This class represents an instance of the nowPlayingState protocol message
        /// </summary>
        public static sealed class NowPlayingState : OutboundMessage {
            NowPlayingState(string state) {
                super("nowPlayingState");
                
                put("state", state);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new NowPlayingUpdate message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This is intended for non-BB10 clients where core does not have a PPS stream for 
        /// media updates. It enables the UI to notify the core of change in the media playing on 
        /// the device. The core will use this to update the nowPlaying message locally and 
        /// with Contacts. Core will smooth these updates to avoid peaks in network load. When 
        /// the core receives this message it will consider this to be the current media and 
        /// update the current playing state to be Playing. The UI should send this message at 
        /// least once per track. Core will not respond directly to this message, but there may 
        /// be updates through a change in the nowPlayingMessage to the UI. 
        /// </p>
        /// </summary>
        /// <param name="artist">The artist name for the current track.</param>
        /// <param name="duration">The duration in milliseconds of the track.</param>
        /// <param name="track">The track name for the current track.</param>
        public static NowPlayingUpdate nowPlayingUpdate(string artist, long duration, string track) {
            return new NowPlayingUpdate(artist, duration, track);
        }

        /// <summary>
        /// This class represents an instance of the nowPlayingUpdate protocol message
        /// </summary>
        public static sealed class NowPlayingUpdate : OutboundMessage {
            NowPlayingUpdate(string artist, long duration, string track) {
                super("nowPlayingUpdate");
                
                put("artist", artist);
                put("duration", duration);
                put("track", track);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PersonalMessageBroadcast message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core broadcast the personal message to the user's contacts, 
        /// without changing the existing personal message. Core will respond with a listAdd 
        /// to the recentUpdate list for the personal message that was broadcast. 
        /// </p>
        /// </summary>
        /// <param name="text">The localized text of the personal message to be broadcast to the user's contacts.</param>
        public static PersonalMessageBroadcast personalMessageBroadcast(string text) {
            return new PersonalMessageBroadcast(text);
        }

        /// <summary>
        /// This class represents an instance of the personalMessageBroadcast protocol message
        /// </summary>
        public static sealed class PersonalMessageBroadcast : OutboundMessage {
            PersonalMessageBroadcast(string text) {
                super("personalMessageBroadcast");
                
                put("text", text);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PictureAcceptHigherQuality message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Sent by the sender to request that core accept an outgoing picture transfer 
        /// request that is currently in the RequestHigherQuality state. If the transfer 
        /// does not exist, is not outgoing, or is not in the 'RequestHigherQuality' state, 
        /// core ignores the message. 
        /// </p>
        /// <p>
        /// 
        /// Core should reply to this message with a listChange message that moves the file 
        /// into either the 'Progressing' or the 'Idle' states, based on whether core is able 
        /// to proceed with the transfer. 
        /// </p>
        /// </summary>
        /// <param name="id">ID of the picture transfer to accept. This is a foreign key into listPicture</param>
        public static PictureAcceptHigherQuality pictureAcceptHigherQuality(string id) {
            return new PictureAcceptHigherQuality(id);
        }

        /// <summary>
        /// This class represents an instance of the pictureAcceptHigherQuality protocol message
        /// </summary>
        public static sealed class PictureAcceptHigherQuality : OutboundMessage {
            PictureAcceptHigherQuality(string id) {
                super("pictureAcceptHigherQuality");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PictureAcceptSend message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Sent by the recipient of a picture transfer to request that core accept an incoming 
        /// picture transfer request that is currently in the RequestSend state. If the 
        /// transfer does not exist, is not incoming, or is not in the 'RequestSend' state, 
        /// core ignores the message. 
        /// </p>
        /// <p>
        /// 
        /// Core should reply to this message with a listChange message that moves the file 
        /// into either the 'Progressing' or the 'Idle' states, based on whether core is able 
        /// to proceed with the transfer. 
        /// </p>
        /// </summary>
        /// <param name="id">ID of the picture transfer to accept. This is a foreign key into listPicture</param>
        public static PictureAcceptSend pictureAcceptSend(string id) {
            return new PictureAcceptSend(id);
        }

        /// <summary>
        /// This class represents an instance of the pictureAcceptSend protocol message
        /// </summary>
        public static sealed class PictureAcceptSend : OutboundMessage {
            PictureAcceptSend(string id) {
                super("pictureAcceptSend");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PictureCancel message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core cancels an active file transfer or request and return to the 
        /// Idle state without deleting any pictures that have been fully downloaded. Any 
        /// partially-downloaded data is deleted. If a fully-downloaded version of the 
        /// picture already exists, that version will not be deleted. 
        /// </p>
        /// <p>
        /// 
        /// This message is the normal mechanism by which requests are denied. If the picture 
        /// transfer was an incoming transfer in the RequestSend state or an outgoing 
        /// transfer in the RequestHigherQuality state, the remote party will be notified 
        /// that their request was denied. This notification happens by setting the 
        /// mostRecentError attribute. 
        /// </p>
        /// <p>
        /// 
        /// This is a no-op if the transfer was already in the Idle state. 
        /// </p>
        /// <p>
        /// 
        /// Core should reply to this message with a listChange message that moves the file 
        /// into the appropriate state and abortReason. 
        /// </p>
        /// </summary>
        /// <param name="id">ID of the picture transfer to cancel. This is a foreign key into listPicture</param>
        public static PictureCancel pictureCancel(string id) {
            return new PictureCancel(id);
        }

        /// <summary>
        /// This class represents an instance of the pictureCancel protocol message
        /// </summary>
        public static sealed class PictureCancel : OutboundMessage {
            PictureCancel(string id) {
                super("pictureCancel");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PictureRequestHigherQuality message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Sent by the recipient to request a higher quality version of a picture if one is 
        /// available. If the transfer does not exist, is not incoming, or does not have a 
        /// higher quality version available, core ignores the message. Core should reply to 
        /// this message with a listChange message that moves the file into the 
        /// RequestHigherQuality state. 
        /// </p>
        /// </summary>
        /// <param name="id">ID of the picture to request. This is a foreign key into listPicture</param>
        public static PictureRequestHigherQuality pictureRequestHigherQuality(string id) {
            return new PictureRequestHigherQuality(id);
        }

        /// <summary>
        /// This class represents an instance of the pictureRequestHigherQuality protocol message
        /// </summary>
        public static sealed class PictureRequestHigherQuality : OutboundMessage {
            PictureRequestHigherQuality(string id) {
                super("pictureRequestHigherQuality");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PingMessage message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core in order to send outgoing ping messages. This 
        /// allows core to deal with all magic characters to use to interpret ping messages 
        /// without the UI needing knowledge of this. Core responds by sending the message to 
        /// every conversation and individual in the 'to' list. It will then insert the 
        /// message into the relevant message histories by sending a set of listAdd messages 
        /// back to the UI. 
        /// </p>
        /// <p>
        /// 
        /// For each individual named in the 'to' list, core will add the message to a 1-on-1 
        /// conversation for that individual. If no such conversation exists, it will create 
        /// a new conversation and will add the, UI of the new active conversation via a listAdd 
        /// message in the conversation list. Since the 'to' field can name multiple 
        /// recipients, this message may trigger the creation of multiple conversations 
        /// </p>
        /// </summary>
        /// <param name="to">Contains any combination of user and conversation URIs, indicating the intended recipients of this message. If the message is addressed to a user (or multiple users), it should be added to an existing 1-on-1 conversation with that user. If no such conversation exists yet, it will be created, resulting in a listAdd message in the active conversations list. If the conversation exists (and is either a multi-chat or 1-on-1 chat), it is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        public static PingMessage pingMessage(List<string> to) {
            return new PingMessage(to);
        }

        /// <summary>
        /// This class represents an instance of the pingMessage protocol message
        /// </summary>
        public static sealed class PingMessage : OutboundMessage {
            PingMessage(List<string> to) {
                super("pingMessage");
                
                put("to", to);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new PostChannelComment message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore to post a new comment item on a channel post or on another 
        /// comment. Note that if the target is a comment, that comment has to be a first level 
        /// comment. We only support two levels of comments, so commenting on another comment 
        /// that is already a child comment is disallowed. 
        /// </p>
        /// <p>
        /// 
        /// If an error occurs, then a 'postChannelCommentError' message describing the 
        /// error is sent to the client that requested the operation with a copy of the cookie 
        /// provided in the request. 
        /// </p>
        /// <p>
        /// 
        /// When a new comment item is created, bbmcore will reply with a sparseElements 
        /// containing the specified cookie. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel</param>
        /// <param name="content">The comment's textual content</param>
        /// <param name="cookie">A cookie that will be referenced when reporting any errors or events associated with this request</param>
        /// <param name="postId">The id of the post that the user is commenting on</param>
        public static PostChannelComment postChannelComment(string channelUri, string content, string cookie, string postId) {
            return new PostChannelComment(channelUri, content, cookie, postId);
        }

        /// <summary>
        /// This class represents an instance of the postChannelComment protocol message
        /// </summary>
        public static sealed class PostChannelComment : OutboundMessage {
            PostChannelComment(string channelUri, string content, string cookie, string postId) {
                super("postChannelComment");
                
                put("channelUri", channelUri);
                put("content", content);
                put("cookie", cookie);
                put("postId", postId);
            }

            /// <summary>
            /// Sets the optional 'parentId' attribute on the message
            /// </summary>
            /// <param name="value">If this comment is regarding a parent comment, this field contains the id of the parent comment that the user is commenting on</param>
            /// <returns>this</returns>
            public PostChannelComment parentId(string value) {
                put("parentId", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ProfileBoxClicked message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Tells core that a profile box has been clicked. Core should repsond by updating all 
        /// children profileBoxItems to read with listChange events. 
        /// </p>
        /// </summary>
        /// <param name="boxId">The tpa for the profile box that has been clicked.</param>
        public static ProfileBoxClicked profileBoxClicked(string boxId) {
            return new ProfileBoxClicked(boxId);
        }

        /// <summary>
        /// This class represents an instance of the profileBoxClicked protocol message
        /// </summary>
        public static sealed class ProfileBoxClicked : OutboundMessage {
            ProfileBoxClicked(string boxId) {
                super("profileBoxClicked");
                
                put("boxId", boxId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ProfileBoxItemClicked message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Tells core that a profile box item has been clicked. Core will attempt to launch the 
        /// application if it can find it on the device; otherwise, it will attempt to launch 
        /// BBWorld to view the application. 
        /// </p>
        /// </summary>
        /// <param name="itemId">The id of the profile box item that has been clicked.</param>
        public static ProfileBoxItemClicked profileBoxItemClicked(string itemId) {
            return new ProfileBoxItemClicked(itemId);
        }

        /// <summary>
        /// This class represents an instance of the profileBoxItemClicked protocol message
        /// </summary>
        public static sealed class ProfileBoxItemClicked : OutboundMessage {
            ProfileBoxItemClicked(string itemId) {
                super("profileBoxItemClicked");
                
                put("itemId", itemId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ProfileBoxItemsRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Marks the profileBoxItems that are specifed in ids to read. Core should respond 
        /// with a listChange event to modify read status on the associated items. 
        /// </p>
        /// </summary>
        /// <param name="ids">The ids of the profile box items that have been read.</param>
        public static ProfileBoxItemsRead profileBoxItemsRead(List<string> ids) {
            return new ProfileBoxItemsRead(ids);
        }

        /// <summary>
        /// This class represents an instance of the profileBoxItemsRead protocol message
        /// </summary>
        public static sealed class ProfileBoxItemsRead : OutboundMessage {
            ProfileBoxItemsRead(List<string> ids) {
                super("profileBoxItemsRead");
                
                put("ids", ids);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ProfileBoxesRead message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Marks the profileBoxes that are specified in ids to read. Core should respond with 
        /// a listChange event to modify read status on the associated items. 
        /// </p>
        /// </summary>
        /// <param name="ids">The ids of the profile box that have been read.</param>
        public static ProfileBoxesRead profileBoxesRead(List<string> ids) {
            return new ProfileBoxesRead(ids);
        }

        /// <summary>
        /// This class represents an instance of the profileBoxesRead protocol message
        /// </summary>
        public static sealed class ProfileBoxesRead : OutboundMessage {
            ProfileBoxesRead(List<string> ids) {
                super("profileBoxesRead");
                
                put("ids", ids);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ProfileChange message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This message is used to change attributes of the local user's profile. If bbmcore 
        /// accepts the change, it will update the local user's metadata in such places as the 
        /// user list and will push the new metadata to members of the contact list 
        /// </p>
        /// </summary>
        public static ProfileChange profileChange() {
            return new ProfileChange();
        }

        /// <summary>
        /// This class represents an instance of the profileChange protocol message
        /// </summary>
        public static sealed class ProfileChange : OutboundMessage {
            ProfileChange() {
                super("profileChange");
                
            }

            /// <summary>
            /// Sets the optional 'dateOfBirth' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains a UTC POSIX timestamp in seconds for the local user's date of birth. If omitted, the date of birth of the local user is unknown. The minimum dateOfBirth allowed is 1900-01-01 00:00:00 UTC and the maximum dateOfBirth allowed is 9999-12-31 23:59:59 UTC.</param>
            /// <returns>this</returns>
            public ProfileChange dateOfBirth(long value) {
                put("dateOfBirth", Long.toString(value));
                return this;
            }

            /// <summary>
            /// Sets the optional 'displayName' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the local user's new display name, as a user-readable string. If omitted, the local user's display name will not be modified.</param>
            /// <returns>this</returns>
            public ProfileChange displayName(string value) {
                put("displayName", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'emailAddress' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the local user's new email address, as a user-readable string. If omitted, the local user's email address will not be modified.</param>
            /// <returns>this</returns>
            public ProfileChange emailAddress(string value) {
                put("emailAddress", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'gender' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the local user's gender. If omitted, the gender of the local user is unknown.</param>
            /// <returns>this</returns>
            public ProfileChange gender(string value) {
                put("gender", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'locale' attribute on the message
            /// </summary>
            /// <param name="value">Contains the local user's locale, in format language_territory. If omitted, the local user's locale will remain unchanged.</param>
            /// <returns>this</returns>
            public ProfileChange locale(string value) {
                put("locale", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'location' attribute on the message
            /// </summary>
            /// <param name="value">If present, this is the new ISO Alpha-2 country code (in upper-case) reported by the local user's device. This can be set independently of timezone. If omitted, the local user's location will remain unchanged.</param>
            /// <returns>this</returns>
            public ProfileChange location(string value) {
                put("location", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'personalMessage' attribute on the message
            /// </summary>
            /// <param name="value">If present, this contains the local user's new personal message, as a user-readable string. If omitted, the local user's personal message will not be modified.</param>
            /// <returns>this</returns>
            public ProfileChange personalMessage(string value) {
                put("personalMessage", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'showLocationTimezone' attribute on the message
            /// </summary>
            /// <param name="value">If present, this indicates whether or not the local user's location and timezone should be shown to members of the contact list. If omitted, the state of this option will not be modified.</param>
            /// <returns>this</returns>
            public ProfileChange showLocationTimezone(bool value) {
                put("showLocationTimezone", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'timezone' attribute on the message
            /// </summary>
            /// <param name="value">If present, this is the new timezone (Olson ID) reported by the local user's device. This can be set independently of location. If omitted, the local user's timezone will remain unchanged.</param>
            /// <returns>this</returns>
            public ProfileChange timezone(string value) {
                put("timezone", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RefreshFeatured message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore refresh featured channels and posts. 
        /// </p>
        /// <p>
        /// 
        /// Core will respond with listAll featuredChannel (not featuredPost) and then 
        /// refresh featured channel and post cache from server. If cache is refreshed, then 
        /// core will send updated featured channels and posts using listAll 
        /// featuredChannel, listAdd post, listAll featuredPost to client. The listAdd 
        /// post is to enable client to cache the featured post data. 
        /// </p>
        /// <p>
        /// 
        /// Deprecated immediately since this is not standard behaviour. 
        /// </p>
        /// </summary>
        public static RefreshFeatured refreshFeatured() {
            return new RefreshFeatured();
        }

        /// <summary>
        /// This class represents an instance of the refreshFeatured protocol message
        /// </summary>
        public static sealed class RefreshFeatured : OutboundMessage {
            RefreshFeatured() {
                super("refreshFeatured");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RefreshStickerPacks message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore redownload all cached sticker packs using the current 
        /// language, process them just like it does in response to a stickerPackPurchased 
        /// message, make any updates necessary to the database, and generate appropriate 
        /// listChange messages. As well, bbmcore should get the list of owned sticker packs 
        /// from the BUS and if there are any extra sticker packs there, download and process 
        /// them too. 
        /// </p>
        /// </summary>
        public static RefreshStickerPacks refreshStickerPacks() {
            return new RefreshStickerPacks();
        }

        /// <summary>
        /// This class represents an instance of the refreshStickerPacks protocol message
        /// </summary>
        public static sealed class RefreshStickerPacks : OutboundMessage {
            RefreshStickerPacks() {
                super("refreshStickerPacks");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ReportLocation message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Report a location to bbmcore for consideration for reporting to ICRS/Intersect. 
        /// Not supported in BB10. This message will be ignored when the locationReporting 
        /// global has enabled == false. 
        /// </p>
        /// <p>
        /// 
        /// Attributes provided that do not meet the restrictions described will be treated 
        /// as a protocol violation and dropped. 
        /// </p>
        /// <p>
        /// 
        /// Best effort should be made to provide all optional attributes, however it is 
        /// understood that on some platforms not all values can be measured efficiently. 
        /// </p>
        /// </summary>
        /// <param name="accuracy">Accuracy of latitude, longitude, and altitude attributes. Given in meters.  Fractional meters are allowed.</param>
        /// <param name="latitude">Latitude of the location at time of fix.  Given in decimal degrees in the range of [-90.0, 90.0].</param>
        /// <param name="longitude">Longitude of the location at time of fix.  Given in decimal degress in the range of [-180.0, 180.0].</param>
        /// <param name="timeOfFix">Unix timestamp representing the time the location fix was obtained.  This is given in seconds.</param>
        public static ReportLocation reportLocation(string accuracy, string latitude, string longitude, long timeOfFix) {
            return new ReportLocation(accuracy, latitude, longitude, timeOfFix);
        }

        /// <summary>
        /// This class represents an instance of the reportLocation protocol message
        /// </summary>
        public static sealed class ReportLocation : OutboundMessage {
            ReportLocation(string accuracy, string latitude, string longitude, long timeOfFix) {
                super("reportLocation");
                
                put("accuracy", accuracy);
                put("latitude", latitude);
                put("longitude", longitude);
                put("timeOfFix", Long.toString(timeOfFix));
            }

            /// <summary>
            /// Sets the optional 'altitude' attribute on the message
            /// </summary>
            /// <param name="value">Altitude at time of fix. Given in meters, can be negative.</param>
            /// <returns>this</returns>
            public ReportLocation altitude(string value) {
                put("altitude", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'fixMode' attribute on the message
            /// </summary>
            /// <param name="value">Location mode used to determine the device's position.</param>
            /// <returns>this</returns>
            public ReportLocation fixMode(string value) {
                put("fixMode", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'heading' attribute on the message
            /// </summary>
            /// <param name="value">Heading at time of measurement.  Given in decimal degress relative to due North (0) and within range [0.0, 360.0].</param>
            /// <returns>this</returns>
            public ReportLocation heading(string value) {
                put("heading", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'velocity' attribute on the message
            /// </summary>
            /// <param name="value">Ground speed in meters/second at the time of measurement.</param>
            /// <returns>this</returns>
            public ReportLocation velocity(string value) {
                put("velocity", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestAllContacts message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core send the UI all the metadata for all members of the user list that 
        /// are in the contact list. The reply will be a listElements message for listUser 
        /// containing a matching cookie and containing exactly those users that are also 
        /// contacts. 
        /// </p>
        /// <p>
        /// 
        /// This is used by the UI on startup to synchronize its contact metadata with bbmcore 
        /// </p>
        /// </summary>
        public static RequestAllContacts requestAllContacts() {
            return new RequestAllContacts();
        }

        /// <summary>
        /// This class represents an instance of the requestAllContacts protocol message
        /// </summary>
        public static sealed class RequestAllContacts : OutboundMessage {
            RequestAllContacts() {
                super("requestAllContacts");
                
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">Holds an optional cookie that was generated by the UI and included in this request. This allows the UI to match up request/response. If present, the daemon will respond with a single listElements with a matching cookie whose elements match exactly those in this request. If the cookie is omitted then the daemon may, at its option, merge multiple requestListElements into a single response or break a single requestListElements into multiple responses.</param>
            /// <returns>this</returns>
            public RequestAllContacts cookie(string value) {
                put("cookie", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestAvatar message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core streams an avatar for the given user to the client via the stream 
        /// message. If the identified uri does not exist or does not have an avatar set, core 
        /// will respond with a streamError message. Core always sends a response to this 
        /// message. If the UI sends the local user's own URI with this message, it is a request 
        /// to fetch the user's own avatar. 
        /// </p>
        /// </summary>
        /// <param name="streamId">A unique (across all active streams) requestId which will be copied into the stream message in response to this request. To ensure uniqueness across core and client generated streamIds the convention is for clients to prefex each id with '<process_id>:'.</param>
        /// <param name="userUri">The uri of the user for which the avatar is being requested.</param>
        public static RequestAvatar requestAvatar(string streamId, string userUri) {
            return new RequestAvatar(streamId, userUri);
        }

        /// <summary>
        /// This class represents an instance of the requestAvatar protocol message
        /// </summary>
        public static sealed class RequestAvatar : OutboundMessage {
            RequestAvatar(string streamId, string userUri) {
                super("requestAvatar");
                
                put("streamId", streamId);
                put("userUri", userUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestChangeAvatar message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core change or remove the local user's avatar. If core accepts the 
        /// new avatar, it responds with appropriate updates. 
        /// </p>
        /// </summary>
        /// <param name="file">Holds the path to the user's new avatar as a path on the local filesystem, or the empty string if this message is requesting that core restore the default avatar.</param>
        /// <param name="type">Holds the MIME type of the new image. This attribute is set to the empty string if and only if the file points to the empty string.</param>
        public static RequestChangeAvatar requestChangeAvatar(string file, string type) {
            return new RequestChangeAvatar(file, type);
        }

        /// <summary>
        /// This class represents an instance of the requestChangeAvatar protocol message
        /// </summary>
        public static sealed class RequestChangeAvatar : OutboundMessage {
            RequestChangeAvatar(string file, string type) {
                super("requestChangeAvatar");
                
                put("file", file);
                put("type", type);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestChangeCategory message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core move one or more contacts between categories. If core accepts 
        /// the request, it responds with a listAdd in the new categoryContents list and a 
        /// listRemove from the old list. 
        /// </p>
        /// </summary>
        /// <param name="contacts">Holds the list of contacts to be moved.</param>
        /// <param name="newCategoryId">Holds the dbid of the desired new category ID for the user</param>
        public static RequestChangeCategory requestChangeCategory(List<string> contacts, long newCategoryId) {
            return new RequestChangeCategory(contacts, newCategoryId);
        }

        /// <summary>
        /// This class represents an instance of the requestChangeCategory protocol message
        /// </summary>
        public static sealed class RequestChangeCategory : OutboundMessage {
            RequestChangeCategory(List<string> contacts, long newCategoryId) {
                super("requestChangeCategory");
                
                put("contacts", contacts);
                put("newCategoryId", newCategoryId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestChannelCommentDelete message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Request that bbmcore removes comment from the channel post 
        /// </p>
        /// <p>
        /// 
        /// If deletion is successful, core will respond with sparseElements with midId 
        /// equals to maxId followed by an empty sparseChunk message. 
        /// </p>
        /// <p>
        /// 
        /// If deletion failed, core will respond with channelDeleteCommentError 
        /// response. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel the postComment belongs to. The URI provided must be unique across the BBM Channels infrastructure.</param>
        /// <param name="postId">Primary key indicating the post that contains the comment to delete.</param>
        public static RequestChannelCommentDelete requestChannelCommentDelete(string channelUri, string postId) {
            return new RequestChannelCommentDelete(channelUri, postId);
        }

        /// <summary>
        /// This class represents an instance of the requestChannelCommentDelete protocol message
        /// </summary>
        public static sealed class RequestChannelCommentDelete : OutboundMessage {
            RequestChannelCommentDelete(string channelUri, string postId) {
                super("requestChannelCommentDelete");
                
                put("channelUri", channelUri);
                put("postId", postId);
            }

            /// <summary>
            /// Sets the optional 'commentId' attribute on the message
            /// </summary>
            /// <param name="value">The comment Id of the post comment to delete. This is the Id field of channelPostComment.</param>
            /// <returns>this</returns>
            public RequestChannelCommentDelete commentId(string value) {
                put("commentId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">The cookie used to track this request. In case of error, it will be returned in the error response channelDeleteCommentError.</param>
            /// <returns>this</returns>
            public RequestChannelCommentDelete cookie(string value) {
                put("cookie", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestChannelPostDelete message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Request that bbmcore removes the post from the channel 
        /// </p>
        /// <p>
        /// 
        /// Core will respond with sparseElements with midId equals to maxId followed by an 
        /// empty sparseChunk message 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel the post was posted on. The URI provided must be unique across the BBM Channels infrastructure. Posts are not supported on channels pending creation.</param>
        /// <param name="postId">Primary key indicating the post to delete</param>
        public static RequestChannelPostDelete requestChannelPostDelete(string channelUri, string postId) {
            return new RequestChannelPostDelete(channelUri, postId);
        }

        /// <summary>
        /// This class represents an instance of the requestChannelPostDelete protocol message
        /// </summary>
        public static sealed class RequestChannelPostDelete : OutboundMessage {
            RequestChannelPostDelete(string channelUri, string postId) {
                super("requestChannelPostDelete");
                
                put("channelUri", channelUri);
                put("postId", postId);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">The cookie used to track this request.</param>
            /// <returns>this</returns>
            public RequestChannelPostDelete cookie(string value) {
                put("cookie", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestChannelPostUpdate message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Request that bbmcore updates a post from the channel. 
        /// </p>
        /// <p>
        /// 
        /// Core will respond with a sparseChange message on the channelPost that was 
        /// successfully updated. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel the post was posted on. The URI provided must be unique across the BBM Channels infrastructure. Posts are not supported on channels pending creation.</param>
        /// <param name="content">The actual plain text content of the updated post.</param>
        /// <param name="postId">Primary key indicating the post to update</param>
        public static RequestChannelPostUpdate requestChannelPostUpdate(string channelUri, string content, string postId) {
            return new RequestChannelPostUpdate(channelUri, content, postId);
        }

        /// <summary>
        /// This class represents an instance of the requestChannelPostUpdate protocol message
        /// </summary>
        public static sealed class RequestChannelPostUpdate : OutboundMessage {
            RequestChannelPostUpdate(string channelUri, string content, string postId) {
                super("requestChannelPostUpdate");
                
                put("channelUri", channelUri);
                put("content", content);
                put("postId", postId);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">The cookie used to track this request.</param>
            /// <returns>this</returns>
            public RequestChannelPostUpdate cookie(string value) {
                put("cookie", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'imagePath' attribute on the message
            /// </summary>
            /// <param name="value">Indicates the full path name to the updated post's image (local to the device).  The image may or may not have an extension and the extension may not match the content type of the image file.</param>
            /// <returns>this</returns>
            public RequestChannelPostUpdate imagePath(string value) {
                put("imagePath", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'title' attribute on the message
            /// </summary>
            /// <param name="value">Title for the updated post.</param>
            /// <returns>this</returns>
            public RequestChannelPostUpdate title(string value) {
                put("title", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestListAdd message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core insert a new element in the list. Most lists do not support this 
        /// message by default. Those that do contain a section in their documentation 
        /// explaining what the message is used for and any restrictions on its use. 
        /// </p>
        /// <p>
        /// 
        /// The documentation for the list indicates a subset of attributes that may be 
        /// present in the requestListAdd message. If the attributes in the subset are marked 
        /// as required in the element schema, then they are also required by the 
        /// requestListAdd message. If they are optional, then they will be reset to their 
        /// default value if not present. 
        /// </p>
        /// </summary>
        /// <param name="elements">Holds the list elements. Each element must include the primary key. If the list type supports this message the documentation for the list type will describe which additional attributes </param>
        /// <param name="type">Determines the namespace for the ID attribute and the schema for the list elements. For the set of valid list types, see the doc/lists subdirectory.</param>
        public static RequestListAdd requestListAdd(List<JSONObject> elements, string type) {
            return new RequestListAdd(elements, type);
        }

        /// <summary>
        /// This class represents an instance of the requestListAdd protocol message
        /// </summary>
        public static sealed class RequestListAdd : OutboundMessage {
            RequestListAdd(List<JSONObject> elements, string type) {
                super("requestListAdd");
                
                put("elements", elements);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">This is only included for nonsingleton lists or lists that retain compatibility with an older nonsingleton list. Identifier for the list, unique for a given list type. The exact meaning and format for list ids is determined by the list type. See the documentation in the doc/lists subdirectory for type-specific rules.</param>
            /// <returns>this</returns>
            public RequestListAdd id(string value) {
                put("id", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestListAll message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core returns the canonical version of the list by responding with a 
        /// listAll message. All lists support this message, except those documented as 
        /// map-only. 
        /// </p>
        /// </summary>
        /// <param name="type">Determines the namespace for the ID attribute and the schema for the list elements. For the set of valid list types, see the doc/lists subdirectory.</param>
        public static RequestListAll requestListAll(string type) {
            return new RequestListAll(type);
        }

        /// <summary>
        /// This class represents an instance of the requestListAll protocol message
        /// </summary>
        public static sealed class RequestListAll : OutboundMessage {
            RequestListAll(string type) {
                super("requestListAll");
                
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">Deprecated in 3.0. This is only sent for nonsingleton lists or singleton lists that retain compatibility for an older nonsingleton list. This is considered deprecated singe nonsingleton lists are discouraged in the latest protocol. Newer clients should send a requestListElements message with a criteria object instead of a requestListAll with an id. This is the identifier for the list, unique for a given list type. The exact meaning and format for list ids is determined by the list type. See the list documentation for type-specific rules.</param>
            /// <returns>this</returns>
            public RequestListAll id(string value) {
                put("id", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestListChange message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core change attributes of one or more elements in the list. Most 
        /// lists do not support this message by default. Those that do contain a section in 
        /// their documentation explaining what the message is used for and any restrictions 
        /// on its use. This message contains partial element states. The primary key is 
        /// always required. The documentation for the list will describe a subset of other 
        /// attributes that may also be present. All attributes are optional, even if they are 
        /// marked as required in the element schema. Elements that are not present remain 
        /// unchanged and are not reset to default values. 
        /// </p>
        /// </summary>
        /// <param name="elements">Holds the list elements. Each element includes the primary key, along with a subset of attributes that should be changed. The set of permissible attributes will be described in the list documentation.</param>
        /// <param name="type">Determines the namespace for the ID attribute and the schema for the list elements. For the set of valid list types, see the doc/lists subdirectory.</param>
        public static RequestListChange requestListChange(List<JSONObject> elements, string type) {
            return new RequestListChange(elements, type);
        }

        /// <summary>
        /// This class represents an instance of the requestListChange protocol message
        /// </summary>
        public static sealed class RequestListChange : OutboundMessage {
            RequestListChange(List<JSONObject> elements, string type) {
                super("requestListChange");
                
                put("elements", elements);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">Identifier for the list, unique for a given list type. The exact meaning and format for list ids is determined by the list type. See the documentation in the doc/lists subdirectory for type-specific rules.</param>
            /// <returns>this</returns>
            public RequestListChange id(string value) {
                put("id", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestListElements message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core send back full states of a given set of elements by responding 
        /// with a listElements message. All lists support this message. The elements in this 
        /// message only contain primary keys. No other attributes may be present, even if 
        /// they are marked as required in the element schema. 
        /// </p>
        /// <p>
        /// 
        /// The deprecated 'id' attribute is retained for compatibility with protocol 
        /// version 2.2 and earlier, which had the notion on nonsingleton lists. If the list 
        /// has a composite key and one or more of the components of the primary key are listed as 
        /// 'idAttributes', then when the id is present, the 'idAttributes' will be omitted 
        /// from the elements. Those attributes will take their value implicitly from the 
        /// content of the id attribute. For example, if listMessage documents that conv is 
        /// considered an idAttribute then "requestListElements":{"id":"foo", 
        /// "elements":[{"messageId":"0"}]} is interpreted the same as 
        /// "requestListElements":{"elements":[{"messageId":"0", "conv":"foo"}]}. 
        /// There isn't always an attribute in 'idAttributes' that has identical semantics 
        /// to the id, but there is always, a 1-to-1 mapping between the two. 
        /// </p>
        /// </summary>
        /// <param name="elements">Specifies the primary keys for the elements being requested.</param>
        /// <param name="type">Determines the namespace for the 'id' attribute and the schema for the list elements. For the set of valid list types, see the doc/lists subdirectory.</param>
        public static RequestListElements requestListElements(List<JSONObject> elements, string type) {
            return new RequestListElements(elements, type);
        }

        /// <summary>
        /// This class represents an instance of the requestListElements protocol message
        /// </summary>
        public static sealed class RequestListElements : OutboundMessage {
            RequestListElements(List<JSONObject> elements, string type) {
                super("requestListElements");
                
                put("elements", elements);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">Holds an optional cookie that was generated by the UI and included in this request. This allows the UI to match up request/response. If present, the daemon will respond with a single listElements with a matching cookie whose elements match exactly those in this request, and the sender will be able to rely on the fact that a missing element is unknown to the daemon. If the cookie is omitted then the daemon may, at its option, merge multiple requestListElements into a single response or break a single requestListElements into multiple responses.</param>
            /// <returns>this</returns>
            public RequestListElements cookie(string value) {
                put("cookie", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">Deprecated in 3.0. This must be present for any nonsingleton list and may be present for any singleton list with compatibility to an older nonsingleton list. All compatible singleton lists will contain a list of 'idAttributes'. When this id is present, the attributes listed in 'idAttributes' may be omitted from the primary key in the elements. Nonsingleton lists are deprecated in 3.0 and so this attribute is also considered deprecated. Identifier for the list, unique for a given list type. The exact meaning and format for list ids is determined by the list type. See the documentation in the doc/lists subdirectory for type-specific rules.</param>
            /// <returns>this</returns>
            public RequestListElements id(string value) {
                put("id", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestListMatching message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core send back full states of all elements that match the given 
        /// criteria in a single listElements message with a matching cookie. 
        /// </p>
        /// <p>
        /// 
        /// Lists do not support this message by default. If the list supports this message, 
        /// its documentation will indicate which attributes may be used as part of the 
        /// criteria block. If the list supports multiple criteria attributes then they may 
        /// be present in any combination. If more than one attribute is present then all the 
        /// listed attributes must match exactly. The resulting listElements message will 
        /// contain all elements for which all criteria match. 
        /// </p>
        /// </summary>
        /// <param name="criteria">Specifies a list of attribute key/value pairs. The attributes must be a subset of the searchCriteria attributes listed in the list documentation.  Iff the list supports requestListAll, empty criteria are allowed and will result in all elements of the list being returned (as listElements).  Lists that do not support requestListAll are map-only lists, and on these lists, the criteria is not permitted to be empty.</param>
        /// <param name="type">Determines the schema and namespace for the list elements.</param>
        public static RequestListMatching requestListMatching(JSONObject criteria, string type) {
            return new RequestListMatching(criteria, type);
        }

        /// <summary>
        /// This class represents an instance of the requestListMatching protocol message
        /// </summary>
        public static sealed class RequestListMatching : OutboundMessage {
            RequestListMatching(JSONObject criteria, string type) {
                super("requestListMatching");
                
                put("criteria", criteria);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">Holds a cookie that was generated by the UI and included in this request. This allows the UI to match up request/response. The daemon will respond with a single listElements with a matching cookie whose elements match exactly those in this request, and the sender will be able to rely on the fact that a missing element is unknown to the daemon.</param>
            /// <returns>this</returns>
            public RequestListMatching cookie(string value) {
                put("cookie", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestListRemove message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core remove one or more elements from the list. By default, most 
        /// lists do not support this message. Those that do contain documentation 
        /// describing the message and any restrictions on its use. The elements in this 
        /// message only contain primary keys. No other attributes may be present, even if 
        /// they are marked as required in the element schema. 
        /// </p>
        /// </summary>
        /// <param name="elements">Holds the list elements. Each element only includes the primary key.</param>
        /// <param name="type">Determines the namespace for the ID attribute and the schema for the list elements. For the set of valid list types, see the doc/lists subdirectory.</param>
        public static RequestListRemove requestListRemove(List<JSONObject> elements, string type) {
            return new RequestListRemove(elements, type);
        }

        /// <summary>
        /// This class represents an instance of the requestListRemove protocol message
        /// </summary>
        public static sealed class RequestListRemove : OutboundMessage {
            RequestListRemove(List<JSONObject> elements, string type) {
                super("requestListRemove");
                
                put("elements", elements);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">This is only sent for nonsingleton lists, or singleton lists that retain compatibility with an older nonsingleton list. Identifier for the list, unique for a given list type. The exact meaning and format for list ids is determined by the list type. See the documentation in the doc/lists subdirectory for type-specific rules.</param>
            /// <returns>this</returns>
            public RequestListRemove id(string value) {
                put("id", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestNewestTextMessages message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This message is used to request the most recently received text message for each 
        /// active participant in a conversation. The list of text messages will be returned 
        /// within a listElements response. 
        /// </p>
        /// </summary>
        /// <param name="contextType">Only those text messages received that include this type of context will be returned. No messages will be returned for a participant that has not sent a message with the given context type. The value specified must be one of the supported 'type' enumerations for the listTextMessageContext list. For now, this message only supports requesting text messages with context.</param>
        /// <param name="conversationUri">The URI of the conversation for the text messages being requested.</param>
        /// <param name="cookie">The required cookie value to be included in the listElements response.</param>
        public static RequestNewestTextMessages requestNewestTextMessages(string contextType, string conversationUri, string cookie) {
            return new RequestNewestTextMessages(contextType, conversationUri, cookie);
        }

        /// <summary>
        /// This class represents an instance of the requestNewestTextMessages protocol message
        /// </summary>
        public static sealed class RequestNewestTextMessages : OutboundMessage {
            RequestNewestTextMessages(string contextType, string conversationUri, string cookie) {
                super("requestNewestTextMessages");
                
                put("contextType", contextType);
                put("conversationUri", conversationUri);
                put("cookie", cookie);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestPicker message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Initiates a picker session with core. This messages passes along information to 
        /// core describing the operation that will be performed when the session completes. 
        /// This information is embedded within the payload and is opaque to the UI. 
        /// </p>
        /// <p>
        /// 
        /// Core responds with a requestPickerResponse message indicating whether or not 
        /// the picker session should proceed. 
        /// </p>
        /// <p>
        /// 
        /// The following is the documentation for the opaque object: 
        /// </p>
        /// <p>
        /// 
        /// DownloadContactPicker{} 
        /// </p>
        /// </summary>
        /// <param name="payload">This JSON object is opaque to the UI. It is defined by core and tells core what type of contact picker is requested and what operation should be peformed after the UI sends contactPickerChoiceSelected.</param>
        /// <param name="tpaUri">This is a foreign key into listTpa.</param>
        public static RequestPicker requestPicker(JSONObject payload, string tpaUri) {
            return new RequestPicker(payload, tpaUri);
        }

        /// <summary>
        /// This class represents an instance of the requestPicker protocol message
        /// </summary>
        public static sealed class RequestPicker : OutboundMessage {
            RequestPicker(JSONObject payload, string tpaUri) {
                super("requestPicker");
                
                put("payload", payload);
                put("tpaUri", tpaUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestProfileBoxImage message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests an image for a profileBoxItem. This request is often sent in response to a 
        /// listUpdate message received from core for the icon attribute. Core responds with 
        /// stream events with the streamId given in this message until finished. 
        /// </p>
        /// </summary>
        /// <param name="icon">The id of the profile box image that is being requested.</param>
        /// <param name="streamId">A globally unique identifier for the stream to request by core to send the image data. No two requests should have the same steamId until that particular stream finishes.</param>
        public static RequestProfileBoxImage requestProfileBoxImage(string icon, string streamId) {
            return new RequestProfileBoxImage(icon, streamId);
        }

        /// <summary>
        /// This class represents an instance of the requestProfileBoxImage protocol message
        /// </summary>
        public static sealed class RequestProfileBoxImage : OutboundMessage {
            RequestProfileBoxImage(string icon, string streamId) {
                super("requestProfileBoxImage");
                
                put("icon", icon);
                put("streamId", streamId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestProfileBoxItems message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests core to poll over RIMIM the profileBoxItems for a given user. Core 
        /// optionally responds by adding or removing any profile boxes and their associated 
        /// items accordingly with listAdd and listRemove on listProfileBox and 
        /// listProfileBoxItem. 
        /// </p>
        /// </summary>
        /// <param name="userUri">The user whose items are being requested</param>
        public static RequestProfileBoxItems requestProfileBoxItems(string userUri) {
            return new RequestProfileBoxItems(userUri);
        }

        /// <summary>
        /// This class represents an instance of the requestProfileBoxItems protocol message
        /// </summary>
        public static sealed class RequestProfileBoxItems : OutboundMessage {
            RequestProfileBoxItems(string userUri) {
                super("requestProfileBoxItems");
                
                put("userUri", userUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestSparseElements message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core send back full states of a given range of elements by responding 
        /// with a sparseElementsMessage. All sparse lists support this message. 
        /// </p>
        /// </summary>
        /// <param name="type">Determines the namespace for the 'id' attribute and the schema for the sparse list elements.  For the set of valid sparse list types, see the doc/sparse subdirectory.</param>
        public static RequestSparseElements requestSparseElements(string type) {
            return new RequestSparseElements(type);
        }

        /// <summary>
        /// This class represents an instance of the requestSparseElements protocol message
        /// </summary>
        public static sealed class RequestSparseElements : OutboundMessage {
            RequestSparseElements(string type) {
                super("requestSparseElements");
                
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'cookie' attribute on the message
            /// </summary>
            /// <param name="value">Holds an optional cookie that was generated by the UI and included in this request. This allows the UI to match up request/response. If present, core will respond with a single sparseElements with a matching cookie.  That single sparseElements will contain the set of elements that fully satisfies the entire range request, or an error indication.  See 'sparseElements' for details on how the elements in the response may vary from the requested range.  If the cookie is omitted then core may, at its option, merge multiple requestSparseElements into a single response or break a single requestSparseElements into multiple responses.</param>
            /// <returns>this</returns>
            public RequestSparseElements cookie(string value) {
                put("cookie", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">Identifier for the sparse list, unique for a given sparse list type.  The exact meaning and format for sparse list ids is determined by the sparse list type.  See the documentation in the doc/sparse subdirectory for type-specific rules.  The ids of the elements within a sparse list are required to form a total ordering.</param>
            /// <returns>this</returns>
            public RequestSparseElements id(string value) {
                put("id", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'limit' attribute on the message
            /// </summary>
            /// <param name="value">This is the optional maximum number of elements that are requested.  This limit may be capped to a reasonable, non-zero value by core.  If omitted, core will use a reasonable value.  Thus, there is intentionally no way to request all elements or a huge number of elements beyond such limits in order to protect against poor or inefficient behavior.  In some sparse lists, it is expected that the 'limit' parameter is rarely used, or used primarily to be set to 1 in order to fetch the "newest" or "oldest" entry at a given position.  The server will endeavour to provide useful, reasonable default limits for all sparse lists.</param>
            /// <returns>this</returns>
            public RequestSparseElements limit(long value) {
                put("limit", Long.toString(value));
                return this;
            }

            /// <summary>
            /// Sets the optional 'maxId' attribute on the message
            /// </summary>
            /// <param name="value">Optional, and mutually exclusive with 'minId', this is the maximum id that should be returned.  This implies that elements with ids equal to or less than this value are requested.  Note that there need not exist an element with this exact id for this request to succeed and produce a valid result.  If both 'minId' and 'maxId' are omitted, this request is interpreted as if 'maxId' were specified as positive infinity (or its equivalent within the domain of the element ids). Note that core may have problem retrieving the inclusive result due to server's limitation. If core is unable to return inclusive result, it will respond with sparseElements message with maxIdInclusive flag set to false.</param>
            /// <returns>this</returns>
            public RequestSparseElements maxId(string value) {
                put("maxId", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'minId' attribute on the message
            /// </summary>
            /// <param name="value">Optional, and mutually exclusive with 'maxId', this is the minimum id that should be returned.  This implies that elements with ids equal to or greater than this value are requested.  Note that there need not exist an element with this exact id for this request to succeed and produce a valid result.  The minimum possible id should be provided as the 'minId' if the request is intended to query for those ids with the minimum possible values. Note that core may have problem retrieving the inclusive result due to server's limitation. If core is unable to return inclusive result, it will respond with sparseElements message with minIdInclusive flag set to false.</param>
            /// <returns>this</returns>
            public RequestSparseElements minId(string value) {
                put("minId", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestTpaIcon message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests an image corresponding to listTpa's appIcon Core responds with stream 
        /// events with the streamId given in this message until finished. 
        /// </p>
        /// </summary>
        /// <param name="streamId">A globally unique identifier for the stream to follow for this request by core of the image data. No two requests should have the same steamId until that particular stream finishes.</param>
        /// <param name="tpaUri">The tpa whose icon is being requested. This is a foreign key into listTpa.</param>
        public static RequestTpaIcon requestTpaIcon(string streamId, string tpaUri) {
            return new RequestTpaIcon(streamId, tpaUri);
        }

        /// <summary>
        /// This class represents an instance of the requestTpaIcon protocol message
        /// </summary>
        public static sealed class RequestTpaIcon : OutboundMessage {
            RequestTpaIcon(string streamId, string tpaUri) {
                super("requestTpaIcon");
                
                put("streamId", streamId);
                put("tpaUri", tpaUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new RequestTransactionLog message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that the daemon reply with a transactionLog message 
        /// </p>
        /// </summary>
        public static RequestTransactionLog requestTransactionLog() {
            return new RequestTransactionLog();
        }

        /// <summary>
        /// This class represents an instance of the requestTransactionLog protocol message
        /// </summary>
        public static sealed class RequestTransactionLog : OutboundMessage {
            RequestTransactionLog() {
                super("requestTransactionLog");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new ResendTextMessage message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to trigger a manual resend of an existing 
        /// textMessage whose status is 'Sending', 'Sent', or 'Failed'. The existing 
        /// message will be resent to the current conversation participants and may be moved 
        /// into the 'Pending', 'Sending', or 'Failed' state. 
        /// </p>
        /// <p>
        /// 
        /// There is no response to this message. The existing textMessage will be updated via 
        /// listChange messages iff it is found, is in the right state, and the operation is 
        /// successful. 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">Holds the URI of the conversation to which this message belongs.</param>
        /// <param name="id">Holds the unique identifier of the existing message to be resent. This is an integer which, combined with the conversation ID, is a foreign key into listMessage.</param>
        public static ResendTextMessage resendTextMessage(string conversationUri, long id) {
            return new ResendTextMessage(conversationUri, id);
        }

        /// <summary>
        /// This class represents an instance of the resendTextMessage protocol message
        /// </summary>
        public static sealed class ResendTextMessage : OutboundMessage {
            ResendTextMessage(string conversationUri, long id) {
                super("resendTextMessage");
                
                put("conversationUri", conversationUri);
                put("id", Long.toString(id));
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new SetupDeviceSwitch message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core start moving the user's profile from the user's other device to 
        /// this one. 
        /// </p>
        /// </summary>
        /// <param name="migrationMessage">The localized message to be broadcast to the user's contacts when the user has migrated to BB10.  Iff this is the empty string, then no such message is broadcast.</param>
        public static SetupDeviceSwitch setupDeviceSwitch(string migrationMessage) {
            return new SetupDeviceSwitch(migrationMessage);
        }

        /// <summary>
        /// This class represents an instance of the setupDeviceSwitch protocol message
        /// </summary>
        public static sealed class SetupDeviceSwitch : OutboundMessage {
            SetupDeviceSwitch(string migrationMessage) {
                super("setupDeviceSwitch");
                
                put("migrationMessage", migrationMessage);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new SetupRestoreFromEmail message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core attempt to perform a migration given one of the user's email 
        /// addresses associated with the account we are attempting to migrate from. This 
        /// will also cause an email with user readable content to be sent, but will be filtered 
        /// by the device. Core will respond by setting the setupState global to the 'Ongoing' 
        /// state as it processes the request. 
        /// </p>
        /// </summary>
        /// <param name="address">Email address associated with the user's account from which we are attemping to restore from.</param>
        /// <param name="body">The localized body of the email sent</param>
        /// <param name="migrationMessage">The localized message to be broadcast to the user's contacts when the user has migrated to BB10.</param>
        /// <param name="subject">The localized subject of the email sent</param>
        public static SetupRestoreFromEmail setupRestoreFromEmail(string address, string body, string migrationMessage, string subject) {
            return new SetupRestoreFromEmail(address, body, migrationMessage, subject);
        }

        /// <summary>
        /// This class represents an instance of the setupRestoreFromEmail protocol message
        /// </summary>
        public static sealed class SetupRestoreFromEmail : OutboundMessage {
            SetupRestoreFromEmail(string address, string body, string migrationMessage, string subject) {
                super("setupRestoreFromEmail");
                
                put("address", address);
                put("body", body);
                put("migrationMessage", migrationMessage);
                put("subject", subject);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new SetupRestoreFromFile message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core start the setup process by restoring from the given file. Core 
        /// will respond by setting the setupState global to the 'Ongoing' state as it 
        /// processes the request. 
        /// </p>
        /// </summary>
        public static SetupRestoreFromFile setupRestoreFromFile() {
            return new SetupRestoreFromFile();
        }

        /// <summary>
        /// This class represents an instance of the setupRestoreFromFile protocol message
        /// </summary>
        public static sealed class SetupRestoreFromFile : OutboundMessage {
            SetupRestoreFromFile() {
                super("setupRestoreFromFile");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new SetupSkip message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that core skip the migration process. Core will respond by changing 
        /// sending a listChange message to the UI that changes the setup state to 'Ongoing' 
        /// while it synchs up the contact list, followed by setting the state to 'Success' 
        /// once it's complete. 
        /// </p>
        /// </summary>
        public static SetupSkip setupSkip() {
            return new SetupSkip();
        }

        /// <summary>
        /// This class represents an instance of the setupSkip protocol message
        /// </summary>
        public static sealed class SetupSkip : OutboundMessage {
            SetupSkip() {
                super("setupSkip");
                
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new StartChannelChat message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests a 1-on-1 conversation with the given channel owner. If there is already a 
        /// 1-on-1 conversation with the given channel owner, core should insert the 
        /// existing messages into this conversation, remove the existing conversation, 
        /// and start using this ID as the ID of the private conversation with the given user. 
        /// That is, this message will essentially cause the ID to change if there is an 
        /// existing conversation with this user. Conversations created with this message 
        /// will have the isConference flag set to false and isChannel set to true. To 
        /// successfully start a chat, the local user must be a subscriber of the channel, and 
        /// the channel must have the chatEnabled flag turned on. 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">URI of the conversation. This will become the primary key of the newly created conversation. It must be a valid conversation URI. See uriformats.txt for details.</param>
        /// <param name="invitee">URI of the channel owner to be invited. This is a foreign key into listUser. This value is specified by listChannel's ownerUri attribute. See uriformats.txt for more info.</param>
        public static StartChannelChat startChannelChat(string conversationUri, string invitee) {
            return new StartChannelChat(conversationUri, invitee);
        }

        /// <summary>
        /// This class represents an instance of the startChannelChat protocol message
        /// </summary>
        public static sealed class StartChannelChat : OutboundMessage {
            StartChannelChat(string conversationUri, string invitee) {
                super("startChannelChat");
                
                put("conversationUri", conversationUri);
                put("invitee", invitee);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new StartChat message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests a 1-on-1 conversation with the given user. If there is already a 1-on-1 
        /// conversation with the given user, core should insert the existing messages into 
        /// this conversation, remove the existing conversation, and start using this ID as 
        /// the ID of the private conversation with the given user. That is, this message will 
        /// essentially cause the ID to change if there is an existing conversation with this 
        /// user. Conversations created with this message will have the isConference flag 
        /// initially set to false. 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">URI of the conversation. This will become the primary key of the newly created conversation. It must be a valid conversation URI. See uriformats.txt for details.</param>
        /// <param name="invitee">URI of the user to be invited. This is a foreign key into listUser. See uriformats.txt for more info.</param>
        public static StartChat startChat(string conversationUri, string invitee) {
            return new StartChat(conversationUri, invitee);
        }

        /// <summary>
        /// This class represents an instance of the startChat protocol message
        /// </summary>
        public static sealed class StartChat : OutboundMessage {
            StartChat(string conversationUri, string invitee) {
                super("startChat");
                
                put("conversationUri", conversationUri);
                put("invitee", invitee);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new StartConference message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Invites zero or more participants to a new conference. The local user becomes the 
        /// conference owner. Core typically responds to this message with a listAdd in the 
        /// listConversation. Conversations started with this message have the 
        /// isConference attribute initially set to true 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">URI of the conference. This will become the primary key of the newly created conference. It must be a valid conversation URI. See uriformats.txt for details.</param>
        /// <param name="invitees">Holds the list of new invitees to the conference. If the list is empty, this creates an empty conference without any participants. Additional participants may be added later by the UI issuing an inviteToConference message.</param>
        public static StartConference startConference(string conversationUri, List<string> invitees) {
            return new StartConference(conversationUri, invitees);
        }

        /// <summary>
        /// This class represents an instance of the startConference protocol message
        /// </summary>
        public static sealed class StartConference : OutboundMessage {
            StartConference(string conversationUri, List<string> invitees) {
                super("startConference");
                
                put("conversationUri", conversationUri);
                put("invitees", invitees);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new StickerMessage message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core in order to send outgoing stickers. Core responds 
        /// by sending the message to every conversation and individual in the 'to' list. It 
        /// will then insert the sticker into the relevant message histories by sending a set 
        /// of listAdd messages back to the UI. 
        /// </p>
        /// </summary>
        /// <param name="alternativeText">The alternative text to send to a user who's version of BBM does not support stickers.</param>
        /// <param name="stickerId">Holds the internal ID of the sticker, generated by core.</param>
        /// <param name="to">Contains any combination of user and conversation URIs, indicating the intended recipients of this message. If the message is addressed to a user (or multiple users), it should be added to an existing 1-on-1 conversation with that user. If no such conversation exists yet, it will be created via a listAdd message in the active conversations list. If the conversation exists (and is either a multi-chat or 1-on-1 chat), it is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        public static StickerMessage stickerMessage(string alternativeText, string stickerId, List<string> to) {
            return new StickerMessage(alternativeText, stickerId, to);
        }

        /// <summary>
        /// This class represents an instance of the stickerMessage protocol message
        /// </summary>
        public static sealed class StickerMessage : OutboundMessage {
            StickerMessage(string alternativeText, string stickerId, List<string> to) {
                super("stickerMessage");
                
                put("alternativeText", alternativeText);
                put("stickerId", stickerId);
                put("to", to);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new StickerPackPurchased message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Requests that bbmcore create an owned sticker pack. When received, core will 
        /// obtain the sticker pack's json file, parse it, obtain all the referenced images, 
        /// cache them locally, add all the stickers to the stickers list, add the sticker pack 
        /// to the stickerPack list, which will reference the stickers in the stickers list, 
        /// and add the sticker pack to localStickerPack list to indicate that we own it and it 
        /// should appear in the UI (in the Sticker Pack Selector). Sticker pack data can be 
        /// fetched at anytime using the StickerPack map-only list. 
        /// </p>
        /// <p>
        /// 
        /// All responses will include the cookie, if set, of this request to allow the 
        /// requesting client to match the response with the request. Responses will be sent 
        /// to all clients to ensure data and state consistency. 
        /// </p>
        /// <p>
        /// 
        /// All well-formed requests will receive a response. If the requesting client 
        /// disconnects before a response is received, the result will be reflected in both 
        /// the localStickerPack and stickerPack lists upon reconnection. On success, the 
        /// localStickerPack list will contain the purchased sticker pack. 
        /// </p>
        /// </summary>
        /// <param name="url">The URL of the sticker pack's json file. It can be either a local file or an external http link. Upon purchase, the sticker store provides us with the json. To ensure it isn't larger than PPS can handle (since it will contain extra info we don't require), it will be saved as a local file.</param>
        public static StickerPackPurchased stickerPackPurchased(string url) {
            return new StickerPackPurchased(url);
        }

        /// <summary>
        /// This class represents an instance of the stickerPackPurchased protocol message
        /// </summary>
        public static sealed class StickerPackPurchased : OutboundMessage {
            StickerPackPurchased(string url) {
                super("stickerPackPurchased");
                
                put("url", url);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new Stream message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Contains a payload of binary data. Used as part of an ongoing data stream. To 
        /// initiate a stream, the sender first sends the recipient a message indicating that 
        /// it intends to begin streaming. There is no generic message used to signal the 
        /// intent to start streaming. Any incoming message can include the beginning of a 
        /// stream as part of its contract. Such messages will include a unique stream 
        /// identifier generated by the sender. This will be attached to all subsequent 
        /// stream messages and will remain unique until the stream closes. The stream 
        /// identifier associates the stream data with the message that initiated the stream 
        /// </p>
        /// <p>
        /// 
        /// The order of stream messages matters. Their payloads are concatenated in the 
        /// order they arrive until the recipient receives a stream message with last=true. 
        /// At that point, the stream is closed and the stream id is free to be recycled by the 
        /// sender. Stream ids may also be recycled when the sender sends a streamError 
        /// message. 
        /// </p>
        /// <p>
        /// 
        /// The sender of stream messages should prioritize them as low as possible. If there 
        /// are any other pending messages waiting to be sent over PPS, they should be sent 
        /// before stream messages 
        /// </p>
        /// </summary>
        public static Stream stream() {
            return new Stream();
        }

        /// <summary>
        /// This class represents an instance of the stream protocol message
        /// </summary>
        public static sealed class Stream : OutboundMessage {
            Stream() {
                super("stream");
                
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">Unique identifier for the stream. This is generated by the sender and will be sent initially to the recipient in the message that initiated the stream. It remains unique as long as the stream stays open.</param>
            /// <returns>this</returns>
            public Stream id(string value) {
                put("id", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'last' attribute on the message
            /// </summary>
            /// <param name="value">Indicates whether this is the last message in the stream. Once the sender sends the last stream message, the stream is closed and the stream ID may be recycled.</param>
            /// <returns>this</returns>
            public Stream last(bool value) {
                put("last", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'value' attribute on the message
            /// </summary>
            /// <param name="value">Contains the base-64-encoded payload, as per this spec http://tools.ietf.org/html/rfc4648#section-4 for details. No extra whitespace or escape characters such as 
 are permitted here.</param>
            /// <returns>this</returns>
            public Stream value(string value) {
                put("value", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new StreamError message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Indicates that the stream was abnormally terminated or could not be opened. No 
        /// further stream messages will be sent on this stream ID and the stream ID may be 
        /// recycled. 
        /// </p>
        /// </summary>
        public static StreamError streamError() {
            return new StreamError();
        }

        /// <summary>
        /// This class represents an instance of the streamError protocol message
        /// </summary>
        public static sealed class StreamError : OutboundMessage {
            StreamError() {
                super("streamError");
                
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">Unique identifier for the stream. This identifier is free to be reused once a streamError occurs.</param>
            /// <returns>this</returns>
            public StreamError id(string value) {
                put("id", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new TagClicked message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// Tells core that a tpa tag has been clicked. Core should respond with the intended 
        /// handler logic - typically launching the app if installed or launch app world to 
        /// that particular app's page. 
        /// </p>
        /// </summary>
        /// <param name="tpaUri">The tpa for the tag that has been clicked.</param>
        public static TagClicked tagClicked(string tpaUri) {
            return new TagClicked(tpaUri);
        }

        /// <summary>
        /// This class represents an instance of the tagClicked protocol message
        /// </summary>
        public static sealed class TagClicked : OutboundMessage {
            TagClicked(string tpaUri) {
                super("tagClicked");
                
                put("tpaUri", tpaUri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new TextMessage message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core in order to send outgoing text messages. Core 
        /// responds by sending the message to every conversation and individual in the 'to' 
        /// list. It will then insert the message into the relevant message histories by 
        /// sending a set of listAdd messages back to the UI. 
        /// </p>
        /// <p>
        /// 
        /// For each individual named in the 'to' list, core will add the message to a 1-on-1 
        /// conversation for that individual. If no such conversation exists, it will create 
        /// a new conversation and will add the, UI of the new active conversation via a listAdd 
        /// message in the conversation list. Since the 'to' field can name multiple 
        /// recipients, this message may trigger the creation of multiple conversations 
        /// </p>
        /// </summary>
        /// <param name="text">Holds the text content of the message</param>
        /// <param name="to">Contains any combination of user and conversation URIs, indicating the intended recipients of this message. If the message is addressed to a user (or multiple users), it should be added to each 1-on-1 conversation with each specified user URI. If, for a given URI, no such conversation exists, neither the message nor the conversation will be created for that user.  If the conversation does exist for a given URI (and is either a multi-chat or 1-on-1 chat), it is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        public static TextMessage textMessage(string text, List<string> to) {
            return new TextMessage(text, to);
        }

        /// <summary>
        /// This class represents an instance of the textMessage protocol message
        /// </summary>
        public static sealed class TextMessage : OutboundMessage {
            TextMessage(string text, List<string> to) {
                super("textMessage");
                
                put("text", text);
                put("to", to);
            }

            /// <summary>
            /// Sets the optional 'broadcast' attribute on the message
            /// </summary>
            /// <param name="value">True if and only if this message is intended as a broadcast. If omitted, the default value is false. Whether or not a message is a broadcast affects how it will be displayed by the recipient, but has nothing to do with the number of recipients. It is possible to have a broadcast with only one recipient and it is possible to have a non-broadcast with multiple recipients.</param>
            /// <returns>this</returns>
            public TextMessage broadcast(bool value) {
                put("broadcast", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new TextMessageWithContext message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core in order to send an outgoing text message with 
        /// extra contextual information included. Core responds by sending the message to 
        /// the individual indicated by the 'to' value. It will then insert the message into 
        /// the relevant message histories by sending a set of listAdd messages back to the UI. 
        /// </p>
        /// <p>
        /// 
        /// For the individual named by the 'to' value, core will add the message to a 1-on-1 
        /// conversation for that individual. If no such conversation exists, core will 
        /// create a new conversation and will add the, UI of the new active conversation via a 
        /// listAdd message in the conversation list. The 'to' field can name only one 
        /// recipient. 
        /// </p>
        /// </summary>
        /// <param name="text">Holds the text content of the message. This will be the only thing displayed on legacy clients for which the context type is unknown, so this string must always be meaningful, even if the metadata is ignored. For certain context types, this text may be ignored on modern clients if the context type is recognized.</param>
        /// <param name="to">Contains either a user or conversation URI, indicating the intended recipient(s) of this message. If the message is addressed to a user, it should be added to the 1-on-1 conversation with that user. If no such conversation exists for that URI, neither the text message nor conversation will be created (and the message is effectively ignored). If the conversation exists (and is either a multi-chat or 1-on-1 chat), the new message is sent to all participants of that conversation. See uriformats.txt for the URI format.</param>
        /// <param name="type">The type of contextual information being provided with the message. For any new types added there should be a similarly named attribute (identical to the type, but with a leading lowercase character) containing the contents of the context provided.</param>
        public static TextMessageWithContext textMessageWithContext(string text, string to, string type) {
            return new TextMessageWithContext(text, to, type);
        }

        /// <summary>
        /// This class represents an instance of the textMessageWithContext protocol message
        /// </summary>
        public static sealed class TextMessageWithContext : OutboundMessage {
            TextMessageWithContext(string text, string to, string type) {
                super("textMessageWithContext");
                
                put("text", text);
                put("to", to);
                put("type", type);
            }

            /// <summary>
            /// Sets the optional 'context' attribute on the message
            /// </summary>
            /// <param name="value">The meta-data used to diplay a realtime location message. This is expected to be present when type is set to RealtimeLocation. It will be included as the contextual information in the outgoing text message. This is deprecated in 3.1, and has been replaced by the realtimeLocation attribute.</param>
            /// <returns>this</returns>
            public TextMessageWithContext context(string value) {
                put("context", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'id' attribute on the message
            /// </summary>
            /// <param name="value">The unique identifier of the referenced recent update. This is expected to be present when type is set to ReferencedBbmRecentUpdate. This will be used to look up the referenced content included as the contextual information in the outgoing text message.</param>
            /// <returns>this</returns>
            public TextMessageWithContext id(string value) {
                put("id", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'realtimeLocation' attribute on the message
            /// </summary>
            /// <param name="value">The meta-data associated with this invitation to view a realtime location</param>
            /// <returns>this</returns>
            public TextMessageWithContext realtimeLocation(JSONObject value) {
                put("realtimeLocation", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'richContent' attribute on the message
            /// </summary>
            /// <param name="value">The meta-data describing the rich content to be shared.  This field is required when type is RichContent.</param>
            /// <returns>this</returns>
            public TextMessageWithContext richContent(JSONObject value) {
                put("richContent", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'sharedUrl' attribute on the message
            /// </summary>
            /// <param name="value">The meta-data used to enhance the display of a URL, the expected content of the text message itself. This will be included as the contextual information in the outgoing text message.</param>
            /// <returns>this</returns>
            public TextMessageWithContext sharedUrl(JSONObject value) {
                put("sharedUrl", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new TpaDownloadAccept message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This message is used to accept a listDownloadInvitation. As a result, core will 
        /// update listDownloadInvitation to Accepted. 
        /// </p>
        /// </summary>
        /// <param name="id"> ID of the invitation to accept.</param>
        public static TpaDownloadAccept tpaDownloadAccept(string id) {
            return new TpaDownloadAccept(id);
        }

        /// <summary>
        /// This class represents an instance of the tpaDownloadAccept protocol message
        /// </summary>
        public static sealed class TpaDownloadAccept : OutboundMessage {
            TpaDownloadAccept(string id) {
                super("tpaDownloadAccept");
                
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new TpaDownloadDecline message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// This message is used to decline a listDownloadInvitation. As a result, core will 
        /// update listDownloadInvitation to Declined As well, listTpa may be changed to 
        /// ignore all download invitations for all contacts. 
        /// </p>
        /// </summary>
        /// <param name="id">ID of the invitation to decline.</param>
        public static TpaDownloadDecline tpaDownloadDecline(string id) {
            return new TpaDownloadDecline(id);
        }

        /// <summary>
        /// This class represents an instance of the tpaDownloadDecline protocol message
        /// </summary>
        public static sealed class TpaDownloadDecline : OutboundMessage {
            TpaDownloadDecline(string id) {
                super("tpaDownloadDecline");
                
                put("id", id);
            }

            /// <summary>
            /// Sets the optional 'ignoreApplication' attribute on the message
            /// </summary>
            /// <param name="value">If true, ignore all future download invitations from this application.  If not present, then this attribute is treated as false.</param>
            /// <returns>this</returns>
            public TpaDownloadDecline ignoreApplication(bool value) {
                put("ignoreApplication", value);
                return this;
            }

            /// <summary>
            /// Sets the optional 'ignoreContact' attribute on the message
            /// </summary>
            /// <param name="value">If true, ignore all future download invitations from this contact. If not present, then this attribute is treated as false.</param>
            /// <returns>this</returns>
            public TpaDownloadDecline ignoreContact(bool value) {
                put("ignoreContact", value);
                return this;
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new TypingNotification message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify it of whether or not the local user is 
        /// currently typing. 
        /// </p>
        /// </summary>
        /// <param name="conversationUri">Holds the URI of the conversation to which this message applies</param>
        /// <param name="typing">Indicates whether the user has started or stopped typing</param>
        public static TypingNotification typingNotification(string conversationUri, bool typing) {
            return new TypingNotification(conversationUri, typing);
        }

        /// <summary>
        /// This class represents an instance of the typingNotification protocol message
        /// </summary>
        public static sealed class TypingNotification : OutboundMessage {
            TypingNotification(string conversationUri, bool typing) {
                super("typingNotification");
                
                put("conversationUri", conversationUri);
                put("typing", typing);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new UnflagChannel message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify that the user would like to remove the 
        /// inappropriate flag for a specific channel which has already been flagged. 
        /// </p>
        /// </summary>
        /// <param name="uri">Holds the unique identifier of the channel that the user is trying to flag.</param>
        public static UnflagChannel unflagChannel(string uri) {
            return new UnflagChannel(uri);
        }

        /// <summary>
        /// This class represents an instance of the unflagChannel protocol message
        /// </summary>
        public static sealed class UnflagChannel : OutboundMessage {
            UnflagChannel(string uri) {
                super("unflagChannel");
                
                put("uri", uri);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new UnflagChannelPost message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify that the user would like to remove the 
        /// inappropriate flag for a specific channel post which has already been flagged. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">The URI of the channel that the post belongs to. It is a foreign key into listChannel and is unique across the entire BBM Channels infrastructure.</param>
        /// <param name="id">Holds the unique identifier of the channel post to flag.</param>
        public static UnflagChannelPost unflagChannelPost(string channelUri, string id) {
            return new UnflagChannelPost(channelUri, id);
        }

        /// <summary>
        /// This class represents an instance of the unflagChannelPost protocol message
        /// </summary>
        public static sealed class UnflagChannelPost : OutboundMessage {
            UnflagChannelPost(string channelUri, string id) {
                super("unflagChannelPost");
                
                put("channelUri", channelUri);
                put("id", id);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new UnflagChannelPostComment message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core to notify that the user would like to remove the 
        /// inappropriate flag for a specific channel post comment which has already been 
        /// flagged. 
        /// </p>
        /// </summary>
        /// <param name="channelUri">Holds the unique identifier of the channel that the post to flag belongs to.</param>
        /// <param name="id">Holds the unique identifier of the channel post comment to flag.</param>
        /// <param name="postId">Holds the unique identifier of the channel post the comment belongs to.</param>
        public static UnflagChannelPostComment unflagChannelPostComment(string channelUri, string id, string postId) {
            return new UnflagChannelPostComment(channelUri, id, postId);
        }

        /// <summary>
        /// This class represents an instance of the unflagChannelPostComment protocol message
        /// </summary>
        public static sealed class UnflagChannelPostComment : OutboundMessage {
            UnflagChannelPostComment(string channelUri, string id, string postId) {
                super("unflagChannelPostComment");
                
                put("channelUri", channelUri);
                put("id", id);
                put("postId", postId);
            }

        }

        /// <summary>
        /// <p>
        /// Creates a new WindowState message, which can be sent using the send() method.
        /// </p>
        /// <p>
        /// The UI sends this message to core with the 'Visible' argument to request that it 
        /// retry its communication with the server if necessary. If bbmcore has sent a 
        /// setupError to the UI due to a persistent server error, this will cause it to retry 
        /// the attempt. The other arguments are deprecated. 
        /// </p>
        /// </summary>
        /// <param name="state">Holds the current state of the UI.</param>
        public static WindowState windowState(string state) {
            return new WindowState(state);
        }

        /// <summary>
        /// This class represents an instance of the windowState protocol message
        /// </summary>
        public static sealed class WindowState : OutboundMessage {
            WindowState(string state) {
                super("windowState");
                
                put("state", state);
            }

        }


            }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the callEvent list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of call events. 
    /// </p>
    /// <p>
    /// 
    /// The following paragraphs describe the members of the 'eventType' enumeration. 
    /// </p>
    /// <p>
    /// 
    /// 'Ended' indicates that the call was ended normally. 
    /// </p>
    /// <p>
    /// 
    /// 'Disconnected' indicates that the call was disconnected. 
    /// </p>
    /// <p>
    /// 
    /// 'Missed' indicates that the call was missed. 
    /// </p>
    /// <p>
    /// 
    /// 'Busy' indicates that the contact was busy. 
    /// </p>
    /// <p>
    /// 
    /// 'Unavailable' indicates that the contact was unavailable. 
    /// </p>
    /// <p>
    /// 
    /// 'Cancelled' indicates that the call was cancelled before the contact accepted. 
    /// </p>
    /// <p>
    /// 
    /// 'Declined' indicates that the call was declined. 
    /// </p>
    /// <p>
    /// 
    /// 'ConnectionError' indicates that an error occurred connecting the call. 
    /// </p>
    /// <p>
    /// 
    /// The following paragraphs describe the members of the 'callType' enumeration. 
    /// </p>
    /// <p>
    /// 
    /// 'Voice' indicates that the call was a voice call. 
    /// </p>
    /// <p>
    /// 
    /// 'Video' indicates that the call was a video call. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the callEvent to fetch</param>
    /// <returns>the element data for the requested callEvent</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public CallEvent getCallEvent(string key) {
      return getMapValue(new ListId("callEvent"), key, typeof(CallEvent));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the callEvent list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getCallEvent contains real data. Otherwise, the result of getCallEvent contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getCallEvent(string)"/>
    /// <param name="key">primary key of the callEvent to fetch</param>
    /// <returns>Existence.YES if the callEvent exists, Existence.NO if the callEvent does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasCallEvent(string key) {
        return getCallEvent(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the callEvent list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getCallEvent(string)"/>
    /// <returns>the element data for the requested callEvent</returns>
    public StateAwareList<CallEvent> getCallEventList() {
        return getList(new ListId("callEvent"), typeof(CallEvent));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the category list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of categories for the user's contact list. The 
    /// category list is only a list of categories themselves, it does not contain the contacts 
    /// contained within each category. 
    /// </p>
    /// <p>
    /// 
    /// The list of users within each category is stored in a categoryContents list whose ID 
    /// matches the ID of the category. When a category is deleted, any users in that category 
    /// will be moved to another category. If there is only one category, core may refuse to 
    /// delete it. 
    /// </p>
    /// <p>
    /// 
    /// The global variable 'defaultCategory' holds the ID of the default category. This is 
    /// the category where newly created contacts are inserted, and where existing contacts 
    /// are moved if their category is deleted. The current implementation of core will always 
    /// make the default category non-deletable. If this should ever change, it will clear the 
    /// canDelete flag from the category. The UI must take care of translating the name of the 
    /// default category, see description of the name property for details. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the category to fetch</param>
    /// <returns>the element data for the requested category</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Category getCategory(string key) {
      return getMapValue(new ListId("category"), key, typeof(Category));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the category list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getCategory contains real data. Otherwise, the result of getCategory contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getCategory(string)"/>
    /// <param name="key">primary key of the category to fetch</param>
    /// <returns>Existence.YES if the category exists, Existence.NO if the category does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasCategory(string key) {
        return getCategory(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the category list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getCategory(string)"/>
    /// <returns>the element data for the requested category</returns>
    public StateAwareList<Category> getCategoryList() {
        return getList(new ListId("category"), typeof(Category));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the categoryContents list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// These lists hold the list of URIs for contacts belonging to each category. There is one 
    /// list per category and the list ID is computed from the category ID. Category contents 
    /// are updated by core when the user requests that a contact changes categories (using a 
    /// requestChangeCategory message). This will cause a corresponding listRemove from 
    /// the old category and a listAdd in the new category. 
    /// </p>
    /// <p>
    /// 
    /// Core may also insert contacts into a category when a new contact is added to the contact 
    /// list or when a category is deleted. Adding a new contact inserts that contact into the 
    /// default category. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the categoryContents to fetch</param> 
    /// <param name="id">The IDs are the decimal string representations of the category IDs and without leading zeroes or whitespace</param>
    /// <returns>the element data for the requested categoryContents</returns>
    
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public CategoryContents getCategoryContents(string key, string id) {
        return getMapValue(new ListId("categoryContents", id), key, typeof(CategoryContents));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the categoryContents list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getCategoryContents contains real data. Otherwise, the result of getCategoryContents contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getCategoryContents(string, string)"/>
    /// <param name="id">The IDs are the decimal string representations of the category IDs and without leading zeroes or whitespace</param>
    /// <param name="key">primary key of the categoryContents to fetch</param>
    /// <returns>Existence.YES if the categoryContents exists, Existence.NO if the categoryContents does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter 
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasCategoryContents(string key, string id) {
        return getCategoryContents(key, id).getExists();
    }
      
    /// <summary>
    /// Returns all elements from the categoryContents list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="BbmdsProtocol#getCategoryContents(string)"/>
    /// <param name="id"></param>
    /// <returns>the element data for the requested categoryContents</returns>
    public StateAwareList<CategoryContents> getCategoryContentsList(string id) {
        return getList(new ListId("categoryContents", id), typeof(CategoryContents));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channel list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list consists of all the BBM Channels that the local user owns, is creating, is 
    /// subscribed to, or has recently queried. The owned, creating, and subscribed channels 
    /// are stored locally. The channels that are returned as part of a temporary result set may 
    /// not be cached locally. As a result requestListElements for channels that are not 
    /// stored locally or cached will trigger a request to the BBM Channels Server to fulfill. 
    /// </p>
    /// <p>
    /// 
    /// This list is restricted and should never be fetched in it's entirety. Instead clients 
    /// should use requestListElements calls with the optional 'elements' restriction in 
    /// order to ask core for the details of any given channel URI(s). 
    /// </p>
    /// <p>
    /// 
    /// When channelCreate is received, core will attempt to create the channel as well as 
    /// uploading the specified image. This is a long running operation which requires 
    /// communication to the BBM Channels infrastructure. 
    /// </p>
    /// <p>
    /// 
    /// Owned channel items will start in a 'Pending' status and progress to a 'Failed' or 
    /// 'Created' status. Channels that are not stored locally will have a status of 'Remote'. 
    /// </p>
    /// <p>
    /// 
    /// Once the channel is a valid channel within the BBM Channels infrastructure, the 
    /// channel will show 'Created' as a status, but the 'mostRecentError' may still indicate 
    /// an image error if the image data was corrupt or invalid. 
    /// </p>
    /// <p>
    /// 
    /// Because this list contains a mix of locally maintained and remote channels a listAdd 
    /// may be received for a remote item already in the list when the channel transitions from 
    /// being transient remote data to being locally maintained. 
    /// </p>
    /// <p>
    /// 
    /// Unless otherwise specified, all fields are limited to 255 Unicode code points and must 
    /// not contain the control characters [U+0000, U+001F] or U+007F. 
    /// </p>
    /// <p>
    /// 
    /// The field sizes and restrictions can be found at 
    /// http://wikis.rim.net/display/bbm/BBM+Channels+-+Field+Size+Limitations 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channel to fetch</param>
    /// <returns>the element data for the requested channel</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Channel getChannel(string key) {
      return mChannel.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channel list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannel contains real data. Otherwise, the result of getChannel contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannel(string)"/>
    /// <param name="key">primary key of the channel to fetch</param>
    /// <returns>Existence.YES if the channel exists, Existence.NO if the channel does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannel(string key) {
        return getChannel(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelCategory list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds the list of localized categories that can be selected for a channel when 
    /// it is created. 
    /// </p>
    /// <p>
    /// 
    /// UI will fetch this list from core whenever it needs it by sending a requestListAll. Core 
    /// replies with a listAll. 
    /// </p>
    /// <p>
    /// 
    /// Core replaces this list when it changes by sending a listAll. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelCategory to fetch</param>
    /// <returns>the element data for the requested channelCategory</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelCategory getChannelCategory(string key) {
      return getMapValue(new ListId("channelCategory"), key, typeof(ChannelCategory));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelCategory list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelCategory contains real data. Otherwise, the result of getChannelCategory contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelCategory(string)"/>
    /// <param name="key">primary key of the channelCategory to fetch</param>
    /// <returns>Existence.YES if the channelCategory exists, Existence.NO if the channelCategory does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelCategory(string key) {
        return getChannelCategory(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the channelCategory list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelCategory(string)"/>
    /// <returns>the element data for the requested channelCategory</returns>
    public StateAwareList<ChannelCategory> getChannelCategoryList() {
        return getList(new ListId("channelCategory"), typeof(ChannelCategory));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelConversation list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the active channel conversation list and currently this list is 
    /// only dedicated for super chat / second level comments chat. Conversations may be 
    /// started at any time by core by sending a listAdd message. There is no explicit message to 
    /// start a super chat by the UI, but UI can remove the chat by requesting 
    /// requestListRemove. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelConversation to fetch</param>
    /// <returns>the element data for the requested channelConversation</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelConversation getChannelConversation(string key) {
      return getMapValue(new ListId("channelConversation"), key, typeof(ChannelConversation));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelConversation list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelConversation contains real data. Otherwise, the result of getChannelConversation contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelConversation(string)"/>
    /// <param name="key">primary key of the channelConversation to fetch</param>
    /// <returns>Existence.YES if the channelConversation exists, Existence.NO if the channelConversation does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelConversation(string key) {
        return getChannelConversation(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the channelConversation list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelConversation(string)"/>
    /// <returns>the element data for the requested channelConversation</returns>
    public StateAwareList<ChannelConversation> getChannelConversationList() {
        return getList(new ListId("channelConversation"), typeof(ChannelConversation));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelInvitation list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of channel invitations for channels. Inviter is 
    /// either the owner or just a subscriber. 
    /// </p>
    /// <p>
    /// 
    /// The following paragraphs describe the members of the 'status' enumeration. 
    /// </p>
    /// <p>
    /// 
    /// 'Pending' indicates that the channel invitation has been sent but invitee has not done 
    /// any acctions yet (neither accepted nor ignored the invitation). 
    /// </p>
    /// <p>
    /// 
    /// 'Accepted' indicates that the channel invitation has been sent to invitee and invitee 
    /// has joined the channel (accepted the invitation). 
    /// </p>
    /// <p>
    /// 
    /// 'Error' indicates that there was an error in sending channel invitation or 
    /// subscribing invitee. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelInvitation to fetch</param>
    /// <returns>the element data for the requested channelInvitation</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelInvitation getChannelInvitation(string key) {
      return getMapValue(new ListId("channelInvitation"), key, typeof(ChannelInvitation));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelInvitation list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelInvitation contains real data. Otherwise, the result of getChannelInvitation contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelInvitation(string)"/>
    /// <param name="key">primary key of the channelInvitation to fetch</param>
    /// <returns>Existence.YES if the channelInvitation exists, Existence.NO if the channelInvitation does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelInvitation(string key) {
        return getChannelInvitation(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the channelInvitation list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelInvitation(string)"/>
    /// <returns>the element data for the requested channelInvitation</returns>
    public StateAwareList<ChannelInvitation> getChannelInvitationList() {
        return getList(new ListId("channelInvitation"), typeof(ChannelInvitation));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelNotification list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of channel notifications for the user. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelNotification to fetch</param>
    /// <returns>the element data for the requested channelNotification</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelNotification getChannelNotification(string key) {
      return getMapValue(new ListId("channelNotification"), key, typeof(ChannelNotification));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelNotification list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelNotification contains real data. Otherwise, the result of getChannelNotification contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelNotification(string)"/>
    /// <param name="key">primary key of the channelNotification to fetch</param>
    /// <returns>Existence.YES if the channelNotification exists, Existence.NO if the channelNotification does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelNotification(string key) {
        return getChannelNotification(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the channelNotification list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelNotification(string)"/>
    /// <returns>the element data for the requested channelNotification</returns>
    public StateAwareList<ChannelNotification> getChannelNotificationList() {
        return getList(new ListId("channelNotification"), typeof(ChannelNotification));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelSearchQuery list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of search queries for channel search. UI sends a 
    /// requestListAdd to start a search. the searchId here will later be used as the id of 
    /// SparseList that holds the content of the search results. It stores the search keywords 
    /// as history entries that can be used for other purposes. UI can also send a 
    /// requestListRemove to remove a search entry if it doesn't want the remember the 
    /// keywords searched. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelSearchQuery to fetch</param>
    /// <returns>the element data for the requested channelSearchQuery</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelSearchQuery getChannelSearchQuery(string key) {
      return getMapValue(new ListId("channelSearchQuery"), key, typeof(ChannelSearchQuery));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelSearchQuery list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelSearchQuery contains real data. Otherwise, the result of getChannelSearchQuery contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelSearchQuery(string)"/>
    /// <param name="key">primary key of the channelSearchQuery to fetch</param>
    /// <returns>Existence.YES if the channelSearchQuery exists, Existence.NO if the channelSearchQuery does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelSearchQuery(string key) {
        return getChannelSearchQuery(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the channelSearchQuery list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelSearchQuery(string)"/>
    /// <returns>the element data for the requested channelSearchQuery</returns>
    public StateAwareList<ChannelSearchQuery> getChannelSearchQueryList() {
        return getList(new ListId("channelSearchQuery"), typeof(ChannelSearchQuery));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelStats list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list maps channel uri and time range onto channel statistics for the 
    /// correspinding channel within that time period. 
    /// </p>
    /// <p>
    /// 
    /// Client cannot ask for the list of all elements. It must always request individual 
    /// mappings using requestListElements. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelStats to fetch</param>
    /// <returns>the element data for the requested channelStats</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelStats getChannelStats(string key) {
      return mChannelStats.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelStats list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelStats contains real data. Otherwise, the result of getChannelStats contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelStats(string)"/>
    /// <param name="key">primary key of the channelStats to fetch</param>
    /// <returns>Existence.YES if the channelStats exists, Existence.NO if the channelStats does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelStats(string key) {
        return getChannelStats(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the channelSubCategory list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds a list of localized subcategories. When a channel is being created, 
    /// user can select a subcategory according to the chosen category for the channel. 
    /// </p>
    /// <p>
    /// 
    /// UI will fetch the list of localized subcategories from core whenever it needs it by 
    /// sending a requestListAll. Core replies with a listAll. 
    /// </p>
    /// <p>
    /// 
    /// Core replaces this list when it changes by sending a listAll. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the channelSubCategory to fetch</param> 
    /// <param name="id">The IDs are unique identifiers of channelCategory records. Each list contains subcategories of a channelCategory uniquely identified by the value of the id field.</param>
    /// <returns>the element data for the requested channelSubCategory</returns>
    
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ChannelSubCategory getChannelSubCategory(string key, string id) {
        return getMapValue(new ListId("channelSubCategory", id), key, typeof(ChannelSubCategory));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the channelSubCategory list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getChannelSubCategory contains real data. Otherwise, the result of getChannelSubCategory contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelSubCategory(string, string)"/>
    /// <param name="id">The IDs are unique identifiers of channelCategory records. Each list contains subcategories of a channelCategory uniquely identified by the value of the id field.</param>
    /// <param name="key">primary key of the channelSubCategory to fetch</param>
    /// <returns>Existence.YES if the channelSubCategory exists, Existence.NO if the channelSubCategory does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter 
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasChannelSubCategory(string key, string id) {
        return getChannelSubCategory(key, id).getExists();
    }
      
    /// <summary>
    /// Returns all elements from the channelSubCategory list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="BbmdsProtocol#getChannelSubCategory(string)"/>
    /// <param name="id"></param>
    /// <returns>the element data for the requested channelSubCategory</returns>
    public StateAwareList<ChannelSubCategory> getChannelSubCategoryList(string id) {
        return getList(new ListId("channelSubCategory", id), typeof(ChannelSubCategory));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the comment list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This map-only list represents BBM Channel post comments. 
    /// </p>
    /// <p>
    /// 
    /// This list is restricted and should never be fetched in its entirety. Instead clients 
    /// should use requestListElements calls with the optional 'elements' restriction in 
    /// order to ask core to retrieve the requested channel post comment content. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the comment to fetch</param>
    /// <returns>the element data for the requested comment</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Comment getComment(string key) {
      return mComment.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the comment list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getComment contains real data. Otherwise, the result of getComment contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getComment(string)"/>
    /// <param name="key">primary key of the comment to fetch</param>
    /// <returns>Existence.YES if the comment exists, Existence.NO if the comment does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasComment(string key) {
        return getComment(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the conferenceInvitation list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of unacknowledged conference invites for 
    /// conferences in which the user is the owner. 
    /// </p>
    /// <p>
    /// 
    /// The following paragraphs describe the members of the 'status' enumeration. 
    /// </p>
    /// <p>
    /// 
    /// 'Pending' indicates that the conference invitation has been sent to the owner of the 
    /// conference, but it has not been accepted or denied yet. 
    /// </p>
    /// <p>
    /// 
    /// 'Accepted' indicates that the conference invitation has been sent to the owner of the 
    /// conference and it has been accepted. 
    /// </p>
    /// <p>
    /// 
    /// 'Denied' indicates that the conference invitation has been sent to the owner of the 
    /// conference and it has been denied. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the conferenceInvitation to fetch</param>
    /// <returns>the element data for the requested conferenceInvitation</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ConferenceInvitation getConferenceInvitation(string key) {
      return getMapValue(new ListId("conferenceInvitation"), key, typeof(ConferenceInvitation));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the conferenceInvitation list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getConferenceInvitation contains real data. Otherwise, the result of getConferenceInvitation contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getConferenceInvitation(string)"/>
    /// <param name="key">primary key of the conferenceInvitation to fetch</param>
    /// <returns>Existence.YES if the conferenceInvitation exists, Existence.NO if the conferenceInvitation does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasConferenceInvitation(string key) {
        return getConferenceInvitation(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the conferenceInvitation list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getConferenceInvitation(string)"/>
    /// <returns>the element data for the requested conferenceInvitation</returns>
    public StateAwareList<ConferenceInvitation> getConferenceInvitationList() {
        return getList(new ListId("conferenceInvitation"), typeof(ConferenceInvitation));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the contact list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the contact list. Elements are added by core in response to 
    /// contactInvitationAccept messages and are removed in response to contactRemove 
    /// messages When a contact is added or removed, core notifies the UI via a listAdd or 
    /// listRemove message respectively. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the contact to fetch</param>
    /// <returns>the element data for the requested contact</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Contact getContact(string key) {
      return getMapValue(new ListId("contact"), key, typeof(Contact));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the contact list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getContact contains real data. Otherwise, the result of getContact contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getContact(string)"/>
    /// <param name="key">primary key of the contact to fetch</param>
    /// <returns>Existence.YES if the contact exists, Existence.NO if the contact does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasContact(string key) {
        return getContact(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the contact list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getContact(string)"/>
    /// <returns>the element data for the requested contact</returns>
    public StateAwareList<Contact> getContactList() {
        return getList(new ListId("contact"), typeof(Contact));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the conversation list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the active conversation list. All conversations in the 
    /// conversation list have an associated message list with a matching ID. The message 
    /// list's lifecycle is not tied to the active conversation list. That is, it is possible to 
    /// have a message list for a conversation even if the conversation isn't in the 
    /// conversation list. Conversations may be started at any time by core by sending a 
    /// listAdd message, and may be requested by the ui by sending a startConference or 
    /// startChat message. 
    /// </p>
    /// <p>
    /// 
    /// Whem bbmcore issues a listRemove for a conversation, it is not necessary to also issue a 
    /// separate listRemove for the messages. The UI will cleanup the (now orphaned) messages 
    /// when appropriate. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the conversation to fetch</param>
    /// <returns>the element data for the requested conversation</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Conversation getConversation(string key) {
      return getMapValue(new ListId("conversation"), key, typeof(Conversation));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the conversation list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getConversation contains real data. Otherwise, the result of getConversation contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getConversation(string)"/>
    /// <param name="key">primary key of the conversation to fetch</param>
    /// <returns>Existence.YES if the conversation exists, Existence.NO if the conversation does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasConversation(string key) {
        return getConversation(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the conversation list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getConversation(string)"/>
    /// <returns>the element data for the requested conversation</returns>
    public StateAwareList<Conversation> getConversationList() {
        return getList(new ListId("conversation"), typeof(Conversation));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the featuredChannel list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This map list holds the set of BBM Channels that are featured for the users current 
    /// location. This list can be refreshed at any time using the requestListAll message for 
    /// this list type. 
    /// </p>
    /// <p>
    /// 
    /// It is important to note that this list can contain URIs for channels that are known to the 
    /// local user as well as ones that are not. This list is not backed by data stored locally and 
    /// can result in a call to the BBM Channels server. As such, no updates will be pushed to this 
    /// list via listAdd, listChange, or listRemove messages. 
    /// </p>
    /// <p>
    /// 
    /// On failure to retrieve the set of featured channels from the BBM Channels server, an 
    /// empty list will be returned. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the featuredChannel to fetch</param>
    /// <returns>the element data for the requested featuredChannel</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public FeaturedChannel getFeaturedChannel(string key) {
      return getMapValue(new ListId("featuredChannel"), key, typeof(FeaturedChannel));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the featuredChannel list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getFeaturedChannel contains real data. Otherwise, the result of getFeaturedChannel contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFeaturedChannel(string)"/>
    /// <param name="key">primary key of the featuredChannel to fetch</param>
    /// <returns>Existence.YES if the featuredChannel exists, Existence.NO if the featuredChannel does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasFeaturedChannel(string key) {
        return getFeaturedChannel(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the featuredChannel list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFeaturedChannel(string)"/>
    /// <returns>the element data for the requested featuredChannel</returns>
    public StateAwareList<FeaturedChannel> getFeaturedChannelList() {
        return getList(new ListId("featuredChannel"), typeof(FeaturedChannel));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the featuredPost list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds a set of featured channel posts. These posts belong to featured 
    /// channels. 
    /// </p>
    /// <p>
    /// 
    /// There is one featuredPost list. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the featuredPost to fetch</param>
    /// <returns>the element data for the requested featuredPost</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public FeaturedPost getFeaturedPost(string key) {
      return getMapValue(new ListId("featuredPost"), key, typeof(FeaturedPost));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the featuredPost list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getFeaturedPost contains real data. Otherwise, the result of getFeaturedPost contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFeaturedPost(string)"/>
    /// <param name="key">primary key of the featuredPost to fetch</param>
    /// <returns>Existence.YES if the featuredPost exists, Existence.NO if the featuredPost does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasFeaturedPost(string key) {
        return getFeaturedPost(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the featuredPost list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFeaturedPost(string)"/>
    /// <returns>the element data for the requested featuredPost</returns>
    public StateAwareList<FeaturedPost> getFeaturedPostList() {
        return getList(new ListId("featuredPost"), typeof(FeaturedPost));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the fileTransfer list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of ongoing and completed file transfers, and their 
    /// status. This list is also the mechanism by which bbmcore reports file transfer 
    /// progress to the UI. At its option, bbmcore may remove any transfer in the 'Aborted' or 
    /// 'Done' state at any time. Also, bbmcore may time out a transfer in the 'Request' or 
    /// 'Progressing' state at any time, thereby placing it in the 'Aborted' state. Removing a 
    /// 'Done' transfer from the list does not delete the downloaded file. 
    /// </p>
    /// <p>
    /// 
    /// The following paragraphs describe the members of the 'abortReason' enumeration. 
    /// </p>
    /// <p>
    /// 
    /// 'GeneralFailure' indicates that some unspecified condition prevented the file 
    /// transfer from completing. This is the general failure case. 
    /// </p>
    /// <p>
    /// 
    /// 'LocalUnsupported' indicates that the local party does not support file transfers of 
    /// this type or at this time (for example, because they are administratively disabled). 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteUnsupported' indicates that the remote party does not support file transfers 
    /// of this type or at this time (for example, because they are administratively 
    /// disabled). 
    /// </p>
    /// <p>
    /// 
    /// 'Declined' indicates that the receiving party rejected the transfer (typically 
    /// during the 'Request' state). 
    /// </p>
    /// <p>
    /// 
    /// 'LocalCancel' indicates that the local party (whether they be sender or receiver) 
    /// cancelled the transfer (typically during the 'Progressing' state). 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteCancel' indicates that the remote party (whether they be sender or receiver) 
    /// cancelled the transfer (typically during the 'Progressing' state). 
    /// </p>
    /// <p>
    /// 
    /// 'Expired' indicates that the remote party indicated that it no longer has knowledge of 
    /// the file transfer (for example, because of a remote reboot). 
    /// </p>
    /// <p>
    /// 
    /// 'TooLarge' indicates that the file was too large to be transferred due to protocol or 
    /// administrative limits. 
    /// </p>
    /// <p>
    /// 
    /// 'WriteError' indicates that the receiver was unable to commit received file data to 
    /// persistent storage. 
    /// </p>
    /// <p>
    /// 
    /// 'FileNotFound' indicates that the sender could not locate the file. 
    /// </p>
    /// <p>
    /// 
    /// 'AccessDenied' indicates that the local party was unable to obtain access to the file 
    /// due to an authorization failure. 
    /// </p>
    /// <p>
    /// 
    /// 'ReadError' indicates that the local party was unable to obtain access to the file 
    /// because of a general error reading from the file. 
    /// </p>
    /// <p>
    /// 
    /// 'Timeout' indicates that either the sender or receiver has determined that it no 
    /// longer wishes to continue this file transfer because it is taking too long to complete. 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteInterrupted' indicates that the remote party interrupted the transfer but 
    /// did not specify a reason. 
    /// </p>
    /// <p>
    /// 
    /// 'TooMany' indicates that the local party has met or exceeded its practical or 
    /// administrative limits on the number of concurrent file transfers. 
    /// </p>
    /// <p>
    /// 
    /// 'ConversationEnded' indicates that the conversation was ended and the transfer was 
    /// automatically terminated as a result. For example, if a conversation is ended, but its 
    /// messages are kept as history, transfers that end up in the history are terminated with 
    /// this reason. 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteIdentityChanged' indicates that some aspect of the remote party's identity 
    /// has changed in such a way that required the transfer to be terminated. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the fileTransfer to fetch</param>
    /// <returns>the element data for the requested fileTransfer</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public FileTransfer getFileTransfer(string key) {
      return getMapValue(new ListId("fileTransfer"), key, typeof(FileTransfer));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the fileTransfer list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getFileTransfer contains real data. Otherwise, the result of getFileTransfer contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFileTransfer(string)"/>
    /// <param name="key">primary key of the fileTransfer to fetch</param>
    /// <returns>Existence.YES if the fileTransfer exists, Existence.NO if the fileTransfer does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasFileTransfer(string key) {
        return getFileTransfer(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the fileTransfer list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFileTransfer(string)"/>
    /// <returns>the element data for the requested fileTransfer</returns>
    public StateAwareList<FileTransfer> getFileTransferList() {
        return getList(new ListId("fileTransfer"), typeof(FileTransfer));
    }
    
    /// <summary>
    /// Returns the elements from the fileTransfer list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFileTransfer(string)"/>
    /// <returns>the element data for the requested fileTransfer matching the criteria</returns>
    public StateAwareList<FileTransfer> getFileTransferList(FileTransferCriteria criteria) {
        return getListMatching(new ListId("fileTransfer"), typeof(FileTransfer), criteria);
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the flaggedChannelPost list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds a set of channel posts. These posts belong to owned channels and have 
    /// been flagged and reported as inappropriate. 
    /// </p>
    /// <p>
    /// 
    /// There is one flaggedChannelPost list for each owned channel. 
    /// </p>
    /// <p>
    /// 
    /// When a flagged post is ignored by the channel owner, UI sends channelIgnorePostFlag 
    /// message to core and core removes the flagged post from this list by a listRemove. 
    /// </p>
    /// <p>
    /// 
    /// Core can add to this list at any time by listAdd. 
    /// </p>
    /// <p>
    /// 
    /// UI displays fixed number of most recent flagged posts from this list. Limit is 
    /// configurable by UI. 
    /// </p>
    /// <p>
    /// 
    /// This is a sorted list based on the time posts have been flagged such that the latest 
    /// flagged post is the first item in the list. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the flaggedChannelPost to fetch</param> 
    /// <param name="id">The IDs are channel URIs. Each list includes flagged posts of a channel uniquely identified by a channel URI.</param>
    /// <returns>the element data for the requested flaggedChannelPost</returns>
    
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public FlaggedChannelPost getFlaggedChannelPost(string key, string id) {
        return getMapValue(new ListId("flaggedChannelPost", id), key, typeof(FlaggedChannelPost));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the flaggedChannelPost list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getFlaggedChannelPost contains real data. Otherwise, the result of getFlaggedChannelPost contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFlaggedChannelPost(string, string)"/>
    /// <param name="id">The IDs are channel URIs. Each list includes flagged posts of a channel uniquely identified by a channel URI.</param>
    /// <param name="key">primary key of the flaggedChannelPost to fetch</param>
    /// <returns>Existence.YES if the flaggedChannelPost exists, Existence.NO if the flaggedChannelPost does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter 
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasFlaggedChannelPost(string key, string id) {
        return getFlaggedChannelPost(key, id).getExists();
    }
      
    /// <summary>
    /// Returns all elements from the flaggedChannelPost list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFlaggedChannelPost(string)"/>
    /// <param name="id"></param>
    /// <returns>the element data for the requested flaggedChannelPost</returns>
    public StateAwareList<FlaggedChannelPost> getFlaggedChannelPostList(string id) {
        return getList(new ListId("flaggedChannelPost", id), typeof(FlaggedChannelPost));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the flaggedChannelPostComment list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds a set of channel post comments. These comments belong to owned channels 
    /// and have been flagged and reported as inappropriate. 
    /// </p>
    /// <p>
    /// 
    /// There is one flaggedChannelPostComment list for each owned channel. 
    /// </p>
    /// <p>
    /// 
    /// When a flagged channel post comment is ignored by the channel owner, UI sends 
    /// channelIgnorePostCommentFlag message to core and core removes the flagged post from 
    /// this list by a listRemove. 
    /// </p>
    /// <p>
    /// 
    /// Core can add to this list at any time by listAdd messages. 
    /// </p>
    /// <p>
    /// 
    /// UI displays fixed number of most recent flagged post comments from this list. Limit is 
    /// configurable by UI. 
    /// </p>
    /// <p>
    /// 
    /// This is a sorted list based on the time post comments have been flagged such that the 
    /// latest flagged comment is the first item in the list. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the flaggedChannelPostComment to fetch</param> 
    /// <param name="id">The IDs are channel URIs. Each list includes flagged post comments of a channel uniquely identified by a channel URI. </param>
    /// <returns>the element data for the requested flaggedChannelPostComment</returns>
    
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public FlaggedChannelPostComment getFlaggedChannelPostComment(string key, string id) {
        return getMapValue(new ListId("flaggedChannelPostComment", id), key, typeof(FlaggedChannelPostComment));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the flaggedChannelPostComment list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getFlaggedChannelPostComment contains real data. Otherwise, the result of getFlaggedChannelPostComment contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFlaggedChannelPostComment(string, string)"/>
    /// <param name="id">The IDs are channel URIs. Each list includes flagged post comments of a channel uniquely identified by a channel URI. </param>
    /// <param name="key">primary key of the flaggedChannelPostComment to fetch</param>
    /// <returns>Existence.YES if the flaggedChannelPostComment exists, Existence.NO if the flaggedChannelPostComment does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter 
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasFlaggedChannelPostComment(string key, string id) {
        return getFlaggedChannelPostComment(key, id).getExists();
    }
      
    /// <summary>
    /// Returns all elements from the flaggedChannelPostComment list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="BbmdsProtocol#getFlaggedChannelPostComment(string)"/>
    /// <param name="id"></param>
    /// <returns>the element data for the requested flaggedChannelPostComment</returns>
    public StateAwareList<FlaggedChannelPostComment> getFlaggedChannelPostCommentList(string id) {
        return getList(new ListId("flaggedChannelPostComment", id), typeof(FlaggedChannelPostComment));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the global list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of global variables exchanged between the UI and 
    /// core. The list uses string keys and mixed-type values. The key is the variable name. The 
    /// set of valid variables and their meaning is documented in the 'globals' section. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the global to fetch</param>
    /// <returns>the element data for the requested global</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Global getGlobal(string key) {
      return mGlobal.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the global list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getGlobal contains real data. Otherwise, the result of getGlobal contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getGlobal(string)"/>
    /// <param name="key">primary key of the global to fetch</param>
    /// <returns>Existence.YES if the global exists, Existence.NO if the global does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasGlobal(string key) {
        return getGlobal(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the localChannel list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds the set of BBM Channels that the local user owns and to which the local 
    /// user is subscribed. It also contains channels that are in the process of being created 
    /// by the owner. 
    /// </p>
    /// <p>
    /// 
    /// When an owned channel moves from a 'Pending' status to a 'Created' status, there will be 
    /// a URI change which will be issued by a listRemove for the old URI followed by a listAdd for 
    /// the new URI. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the localChannel to fetch</param>
    /// <returns>the element data for the requested localChannel</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public LocalChannel getLocalChannel(string key) {
      return getMapValue(new ListId("localChannel"), key, typeof(LocalChannel));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the localChannel list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getLocalChannel contains real data. Otherwise, the result of getLocalChannel contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getLocalChannel(string)"/>
    /// <param name="key">primary key of the localChannel to fetch</param>
    /// <returns>Existence.YES if the localChannel exists, Existence.NO if the localChannel does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasLocalChannel(string key) {
        return getLocalChannel(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the localChannel list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getLocalChannel(string)"/>
    /// <returns>the element data for the requested localChannel</returns>
    public StateAwareList<LocalChannel> getLocalChannelList() {
        return getList(new ListId("localChannel"), typeof(LocalChannel));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the localStickerPack list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This map list holds the set of sticker packs that the local user owns. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the localStickerPack to fetch</param>
    /// <returns>the element data for the requested localStickerPack</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public LocalStickerPack getLocalStickerPack(string key) {
      return getMapValue(new ListId("localStickerPack"), key, typeof(LocalStickerPack));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the localStickerPack list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getLocalStickerPack contains real data. Otherwise, the result of getLocalStickerPack contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getLocalStickerPack(string)"/>
    /// <param name="key">primary key of the localStickerPack to fetch</param>
    /// <returns>Existence.YES if the localStickerPack exists, Existence.NO if the localStickerPack does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasLocalStickerPack(string key) {
        return getLocalStickerPack(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the localStickerPack list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getLocalStickerPack(string)"/>
    /// <returns>the element data for the requested localStickerPack</returns>
    public StateAwareList<LocalStickerPack> getLocalStickerPackList() {
        return getList(new ListId("localStickerPack"), typeof(LocalStickerPack));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the location list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds all the locations information of the user. 
    /// </p>
    /// <p>
    /// 
    /// Locations are inserted into this list using the requestListAdd message which will 
    /// happen whenever the user wants to send his location to a contact immediately. If the 
    /// user would like to send one of his recent locations, the UI would first need to fetch the 
    /// list of locations and send the selected one using locationSend message. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the location to fetch</param>
    /// <returns>the element data for the requested location</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Location getLocation(string key) {
      return getMapValue(new ListId("location"), key, typeof(Location));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the location list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getLocation contains real data. Otherwise, the result of getLocation contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getLocation(string)"/>
    /// <param name="key">primary key of the location to fetch</param>
    /// <returns>Existence.YES if the location exists, Existence.NO if the location does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasLocation(string key) {
        return getLocation(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the location list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getLocation(string)"/>
    /// <returns>the element data for the requested location</returns>
    public StateAwareList<Location> getLocationList() {
        return getList(new ListId("location"), typeof(Location));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the message list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list is used to store the messages in a conversation. There is one list per 
    /// conversation. These lists are map-only lists, meaning that they won't fire the 
    /// listAdd, listRemove, and listAll messages -- callers must explicitly request items 
    /// using listRequestElement. The IDs for this list are consecutive integers. 
    /// </p>
    /// <p>
    /// 
    /// The range of valid message IDs for a given conversation are encoded in 
    /// listConversation. When a new message is added to a conversation, core will notify the 
    /// UI via a change event in the conversation list which updates lastMessage and/or 
    /// numMessages. It may also, at its option, push the newly added message to the UI via a 
    /// listElements message in listMessage. When the UI recieves the updated end index in 
    /// listConversation, it may request the new messages via a requestListElements. 
    /// </p>
    /// <p>
    /// 
    /// When requesting elements from this list, it is most efficient to request them in 
    /// batches. That is, a small number of requestListElements messages containing a large 
    /// number of elements per request will be dealt with more efficiently than a large number 
    /// of requestListElements messages containing a small number of elements per request. 
    /// </p>
    /// <p>
    /// 
    /// Each message has a type, enumerated by the 'type' field. The valid enumeration members 
    /// are: 
    /// </p>
    /// <p>
    /// 
    /// 'Text': The message is an ordinary text message. 
    /// </p>
    /// <p>
    /// 
    /// 'Ping': The message is a ping. 
    /// </p>
    /// <p>
    /// 
    /// 'Broadcast': The message is a broadcast message. 
    /// </p>
    /// <p>
    /// 
    /// 'System': The message is a BBM Server system message. 
    /// </p>
    /// <p>
    /// 
    /// 'FileTransfer': The message is a file transfer message. 
    /// </p>
    /// <p>
    /// 
    /// 'PictureTransfer': The message is a picture transfer message. 
    /// </p>
    /// <p>
    /// 
    /// 'HighQualityPictureReq': The message is a request from the 'senderUri' for the large 
    /// version of a previously sent picture. The 'pictureTransferId' will be present and 
    /// will point to the picture list entry associated with both the original small picture 
    /// transfer and this request for the large picture. The picture list entry can be in any 
    /// valid state where its 'incoming' field is false and its 'success' field is true. When 
    /// the picture list entry 'status' is 'RequestHigherQuality', core will accept the 
    /// 'pictureAcceptHigherQuality' (or 'pictureCancel') message in reference to the 
    /// picture. 
    /// </p>
    /// <p>
    /// 
    /// 'ConfIncomingInviteReq': The message is a conference invite request. This appears 
    /// in the message history if the local user is the conference owner and one of the 
    /// participants is requesting our permission to invite a third party to the conference. 
    /// Messages of this type include the confInviteRequestId attribute, which 
    /// cross-references listConferenceInvitation for additional metadata. 
    /// </p>
    /// <p>
    /// 
    /// 'ConfOutgoingInviteReq': The message is a notification that the local user has asked 
    /// the conference owner for permission to add the 'senderUri' to the conference. In the 
    /// event that the invitation is accepted, this will generally be followed shortly by a 
    /// ConfInvited message. 
    /// </p>
    /// <p>
    /// 
    /// 'ConfOutgoingInviteReqDenied': The message is a notification that the conference 
    /// owner has denied the request to add 'senderUri' to the conference. This normally 
    /// appears in the message history at some point after a matching ConfOutgoingInviteReq 
    /// message 
    /// </p>
    /// <p>
    /// 
    /// 'ConfWeJoined': The message marks the point in the message history where the local 
    /// user joined the conference. It will normally be the first message in the history since 
    /// there is currently no way for a user to view the conference message history prior to the 
    /// time they joined. It may not be present if older history has been purged. The set of 
    /// initial participants can be obtained from listConversation, if it is known to core. 
    /// 'senderUri' points to the user that invited us to the conversation. 
    /// </p>
    /// <p>
    /// 
    /// 'ConfInvited': The message is a notification that the local user has invited 
    /// 'senderUri' to join the conference. In public conferences, this message appears at 
    /// the point where the local user sent the invite. In private conferences, this generally 
    /// follows a ConfOutgoingInviteReq message. If the recipient receives the invite and we 
    /// have the appropriate permissions, this will be followed by a ConfUserJoined message 
    /// </p>
    /// <p>
    /// 
    /// 'ConfUserJoined': The message is a notification that 'senderUri' has joined the 
    /// conference. If we sent the invite, this will generally follow a ConfInvited message. 
    /// If the invite was sent by another party, the message will appear on its own 
    /// </p>
    /// <p>
    /// 
    /// 'ConfUserLeft': The message is a notification that the 'senderUri' has left the 
    /// conference. 
    /// </p>
    /// <p>
    /// 
    /// 'ChannelParticipantLeft': The message is a notification that the channel chat 
    /// participant identified by the 'senderUri' has left the chat. 
    /// </p>
    /// <p>
    /// 
    /// 'Location': The message is a location message. 
    /// </p>
    /// <p>
    /// 
    /// 'ContactReInvite': The message is a notification from the contact that the user is no 
    /// longer part of their contact list. The user must either re-invite the contact or delete 
    /// them from their list. 
    /// </p>
    /// <p>
    /// 
    /// 'CallEvent': The message is a call event. 
    /// </p>
    /// <p>
    /// 
    /// 'ChannelInvitation': The message is a channel invitation message. 
    /// </p>
    /// <p>
    /// 
    /// 'TextWithContext': The message contains referenced content. 
    /// </p>
    /// <p>
    /// 
    /// 'Sticker': The message is a sticker message. 
    /// </p>
    /// <p>
    /// 
    /// 'SharedAd': The message is an Ad. 
    /// </p>
    /// <p>
    /// 
    /// Each message has a 'status' field that reflects its delivery status. These status 
    /// values apply to inbound and outbound messages. The valid enumeration members are: 
    /// </p>
    /// <p>
    /// 
    /// 'Pending': The message is waiting to be sent. 
    /// </p>
    /// <p>
    /// 
    /// 'Failed': The message failed to be sent or delivered. 
    /// </p>
    /// <p>
    /// 
    /// 'Sending': The message has been sent but has not been acked by the BBM network 
    /// infrastructure. 
    /// </p>
    /// <p>
    /// 
    /// 'Sent': The message has been transmitted and subsequently acked by the network 
    /// infrastructure. 
    /// </p>
    /// <p>
    /// 
    /// 'Delivered': The message has been delivered to at least one recipient. 
    /// </p>
    /// <p>
    /// 
    /// 'Read': The message has been read by at least one recipient. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the message to fetch</param>
    /// <returns>the element data for the requested message</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Message getMessage(string key) {
      return mMessage.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the message list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getMessage contains real data. Otherwise, the result of getMessage contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getMessage(string)"/>
    /// <param name="key">primary key of the message to fetch</param>
    /// <returns>Existence.YES if the message exists, Existence.NO if the message does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasMessage(string key) {
        return getMessage(key).getExists();
    }
    
    /// <summary>
    /// Returns the elements from the message list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getMessage(string)"/>
    /// <returns>the element data for the requested message matching the criteria</returns>
    public StateAwareList<Message> getMessageList(MessageCriteria criteria) {
        return getListMatching(new ListId("message"), typeof(Message), criteria);
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the pendingContact list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the pending contact list. Elements are added indirectly by the UI 
    /// when it invites a contact via the contactInvitation or contactEmailInvitation 
    /// messages, and are removed when the UI responds to a request via a 
    /// contactInvitationAccept or contactInvitationDelete message. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the pendingContact to fetch</param>
    /// <returns>the element data for the requested pendingContact</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public PendingContact getPendingContact(string key) {
      return getMapValue(new ListId("pendingContact"), key, typeof(PendingContact));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the pendingContact list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPendingContact contains real data. Otherwise, the result of getPendingContact contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPendingContact(string)"/>
    /// <param name="key">primary key of the pendingContact to fetch</param>
    /// <returns>Existence.YES if the pendingContact exists, Existence.NO if the pendingContact does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPendingContact(string key) {
        return getPendingContact(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the pendingContact list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPendingContact(string)"/>
    /// <returns>the element data for the requested pendingContact</returns>
    public StateAwareList<PendingContact> getPendingContactList() {
        return getList(new ListId("pendingContact"), typeof(PendingContact));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the pendingPost list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the pending post list. Elements are added directly by the UI using 
    /// requestListAdd with the desired data to be posted. Once the post has been successfully 
    /// created in the BBM Channel infrastructure, the item will be removed from this list and 
    /// be pushed to the client using the 'sparseChannelPost' message. Note: When using 
    /// requestListAll: this results in retrieval of the entire set of pendingPosts of all the 
    /// channels for the currently authenticated user. Requests pendingPosts by a specific 
    /// channelUri is not supported. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the pendingPost to fetch</param>
    /// <returns>the element data for the requested pendingPost</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public PendingPost getPendingPost(string key) {
      return getMapValue(new ListId("pendingPost"), key, typeof(PendingPost));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the pendingPost list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPendingPost contains real data. Otherwise, the result of getPendingPost contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPendingPost(string)"/>
    /// <param name="key">primary key of the pendingPost to fetch</param>
    /// <returns>Existence.YES if the pendingPost exists, Existence.NO if the pendingPost does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPendingPost(string key) {
        return getPendingPost(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the pendingPost list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPendingPost(string)"/>
    /// <returns>the element data for the requested pendingPost</returns>
    public StateAwareList<PendingPost> getPendingPostList() {
        return getList(new ListId("pendingPost"), typeof(PendingPost));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the picture list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of ongoing and completed picture transfers, and 
    /// their status. This list is also the mechanism by which bbmcore reports transfer 
    /// progress to the UI. At its option, bbmcore may remove any transfer at any time. Unlike 
    /// with file transfers, when core removes a picture transfer it also deletes any 
    /// associated thumbnails, partially downloaded pictures, and fully downloaded 
    /// pictures. Core will generally delete a picture transfer when the picture is no longer 
    /// visible in a chat or when explicitly canceled by the user. Since the files may be deleted 
    /// by core at any time, the UI must be prepared to deal with missing files referenced in this 
    /// list. bbmcore may time out a transfer in the 'RequestSend', 'RequestHigherQuality', 
    /// or 'Progressing' state at any time. 
    /// </p>
    /// <p>
    /// 
    /// The following diagram demonstrates the flow of state changes in listPicture and 
    /// listFileTransfer: <img src="img/FileTransfer.jpg" width="100%"> 
    /// </p>
    /// <p>
    /// 
    /// A typical sequence of state changes would be: RequestSend -> Progressing -> Idle -> 
    /// RequestHigherQuality -> Progressing -> Idle 
    /// </p>
    /// <p>
    /// 
    /// Notice that the Idle state is not terminal. Idle indicates that no transfer is 
    /// currently ongoing and neither party is waiting for a request. If the 
    /// higherQualityAvailable flag is true, the picture transfer can later go to the 
    /// RequestHigherQuality state if the recipient requests a higher quality version of the 
    /// picture. 
    /// </p>
    /// <p>
    /// 
    /// The mostRecentError field can be present in the Idle state. It holds the most recent 
    /// error condition. If success is false, then this would be the reason why the transfer 
    /// failed. If success is true, then this is the reason why the most recent request for a 
    /// higher quality image failed. The following paragraphs describe the members of the 
    /// 'mostRecentError' enumeration. 
    /// </p>
    /// <p>
    /// 
    /// 'GeneralFailure' indicates that some unspecified condition prevented the file 
    /// transfer from completing. This is the general failure case. 
    /// </p>
    /// <p>
    /// 
    /// 'LocalUnsupported' indicates that the local party does not support file transfers of 
    /// this type or at this time (for example, because they are administratively disabled). 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteUnsupported' indicates that the remote party does not support file transfers 
    /// of this type or at this time (for example, because they are administratively 
    /// disabled). 
    /// </p>
    /// <p>
    /// 
    /// 'Declined' indicates that the receiving party rejected the transfer (typically 
    /// during the 'Request' state). 
    /// </p>
    /// <p>
    /// 
    /// 'LocalCancel' indicates that the local party (whether they be sender or receiver) 
    /// cancelled the transfer (typically during the 'Progressing' state). 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteCancel' indicates that the remote party (whether they be sender or receiver) 
    /// cancelled the transfer (typically during the 'Progressing' state). 
    /// </p>
    /// <p>
    /// 
    /// 'Expired' indicates that the remote party indicated that it no longer has knowledge of 
    /// the file transfer (for example, because of a remote reboot). 
    /// </p>
    /// <p>
    /// 
    /// 'TooLarge' indicates that the file was too large to be transferred due to protocol or 
    /// administrative limits. 
    /// </p>
    /// <p>
    /// 
    /// 'WriteError' indicates that the receiver was unable to commit received file data to 
    /// persistent storage. 
    /// </p>
    /// <p>
    /// 
    /// 'FileNotFound' indicates that the sender could not locate the file. 
    /// </p>
    /// <p>
    /// 
    /// 'AccessDenied' indicates that the sender was unable to obtain access to the file due to 
    /// an authorization failure. 
    /// </p>
    /// <p>
    /// 
    /// 'ReadError' indicates that the sender was unable to obtain access to the file because 
    /// of a general error reading from the file. 
    /// </p>
    /// <p>
    /// 
    /// 'Timeout' indicates that either the sender or receiver has determined that it no 
    /// longer wishes to continue this file transfer because it is taking too long to complete. 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteInterrupted' indicates that the remote party interrupted the transfer but 
    /// did not specify a reason. 
    /// </p>
    /// <p>
    /// 
    /// 'TooMany' indicates that the local party has met or exceeded its practical or 
    /// administrative limits on the number of concurrent file transfers. 
    /// </p>
    /// <p>
    /// 
    /// 'ConversationEnded' indicates that the conversation was ended and the transfer was 
    /// automatically terminated as a result. For example, if a conversation is ended, but its 
    /// messages are kept as history, transfers that end up in the history are terminated with 
    /// this reason. 
    /// </p>
    /// <p>
    /// 
    /// 'RemoteIdentityChanged' indicates that some aspect of the remote party's identity 
    /// has changed in such a way that required the transfer to be terminated. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the picture to fetch</param>
    /// <returns>the element data for the requested picture</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Picture getPicture(string key) {
      return getMapValue(new ListId("picture"), key, typeof(Picture));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the picture list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPicture contains real data. Otherwise, the result of getPicture contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPicture(string)"/>
    /// <param name="key">primary key of the picture to fetch</param>
    /// <returns>Existence.YES if the picture exists, Existence.NO if the picture does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPicture(string key) {
        return getPicture(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the picture list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPicture(string)"/>
    /// <returns>the element data for the requested picture</returns>
    public StateAwareList<Picture> getPictureList() {
        return getList(new ListId("picture"), typeof(Picture));
    }
    
    /// <summary>
    /// Returns the elements from the picture list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPicture(string)"/>
    /// <returns>the element data for the requested picture matching the criteria</returns>
    public StateAwareList<Picture> getPictureList(PictureCriteria criteria) {
        return getListMatching(new ListId("picture"), typeof(Picture), criteria);
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the pinToUser list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list contains, at minimum, all pins for any user that appears in the contact list. 
    /// No guarantees are made for users outside this set. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the pinToUser to fetch</param>
    /// <returns>the element data for the requested pinToUser</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public PinToUser getPinToUser(string key) {
      return mPinToUser.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the pinToUser list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPinToUser contains real data. Otherwise, the result of getPinToUser contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPinToUser(string)"/>
    /// <param name="key">primary key of the pinToUser to fetch</param>
    /// <returns>Existence.YES if the pinToUser exists, Existence.NO if the pinToUser does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPinToUser(string key) {
        return getPinToUser(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the platformDisabledUsers list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// A platform disabled user is one who is running BBM 6+ but is IT policy disabled from using 
    /// or receiving any platform notifications or invites. This information is used in the UI 
    /// to filter the contact picker to not contain these people. This is used to store the 
    /// disabled platform user list. Elements are added by core in response to messages from 
    /// RIM_IM telling them that a contact has disabled platform for all platform apps. When a 
    /// contact is added or removed, core notifies the UI via a listAdd or listRemove message 
    /// respectively. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the platformDisabledUsers to fetch</param>
    /// <returns>the element data for the requested platformDisabledUsers</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public PlatformDisabledUsers getPlatformDisabledUsers(string key) {
      return getMapValue(new ListId("platformDisabledUsers"), key, typeof(PlatformDisabledUsers));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the platformDisabledUsers list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPlatformDisabledUsers contains real data. Otherwise, the result of getPlatformDisabledUsers contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPlatformDisabledUsers(string)"/>
    /// <param name="key">primary key of the platformDisabledUsers to fetch</param>
    /// <returns>Existence.YES if the platformDisabledUsers exists, Existence.NO if the platformDisabledUsers does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPlatformDisabledUsers(string key) {
        return getPlatformDisabledUsers(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the platformDisabledUsers list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPlatformDisabledUsers(string)"/>
    /// <returns>the element data for the requested platformDisabledUsers</returns>
    public StateAwareList<PlatformDisabledUsers> getPlatformDisabledUsersList() {
        return getList(new ListId("platformDisabledUsers"), typeof(PlatformDisabledUsers));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the platformIgnoredUsers list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the list of users for whom we're ignoring all TPA requests. 
    /// </p>
    /// <p>
    /// 
    /// Elements may be added by core at any time, and it will notify the UI of this via a listAdd 
    /// message. Elements are normally added by core when the UI sends a tpaJoinDecline with 
    /// the 'ingnoreContact' attribute set to true. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the platformIgnoredUsers to fetch</param>
    /// <returns>the element data for the requested platformIgnoredUsers</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public PlatformIgnoredUsers getPlatformIgnoredUsers(string key) {
      return getMapValue(new ListId("platformIgnoredUsers"), key, typeof(PlatformIgnoredUsers));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the platformIgnoredUsers list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPlatformIgnoredUsers contains real data. Otherwise, the result of getPlatformIgnoredUsers contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPlatformIgnoredUsers(string)"/>
    /// <param name="key">primary key of the platformIgnoredUsers to fetch</param>
    /// <returns>Existence.YES if the platformIgnoredUsers exists, Existence.NO if the platformIgnoredUsers does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPlatformIgnoredUsers(string key) {
        return getPlatformIgnoredUsers(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the platformIgnoredUsers list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPlatformIgnoredUsers(string)"/>
    /// <returns>the element data for the requested platformIgnoredUsers</returns>
    public StateAwareList<PlatformIgnoredUsers> getPlatformIgnoredUsersList() {
        return getList(new ListId("platformIgnoredUsers"), typeof(PlatformIgnoredUsers));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the post list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This map-only list represents BBM Channel posts. 
    /// </p>
    /// <p>
    /// 
    /// This list is restricted and should never be fetched in its entirety. Instead clients 
    /// should use requestListElements calls with the optional 'elements' restriction in 
    /// order to ask core to retrieve the requested channel post content. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the post to fetch</param>
    /// <returns>the element data for the requested post</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Post getPost(string key) {
      return mPost.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the post list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPost contains real data. Otherwise, the result of getPost contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPost(string)"/>
    /// <param name="key">primary key of the post to fetch</param>
    /// <returns>Existence.YES if the post exists, Existence.NO if the post does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPost(string key) {
        return getPost(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the postImage list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list consists of all the BBM Channel post images. 
    /// </p>
    /// <p>
    /// 
    /// This list is restricted and should never be fetched in it's entirety. Instead clients 
    /// should use requestListElements calls with the optional 'elements' restriction in 
    /// order to ask core to retrieve the requested channel post image external URLs. If core is 
    /// successful in downloading and caching an image, it will return the URL to the local 
    /// image file, otherwise it will return the originally requested URL. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the postImage to fetch</param>
    /// <returns>the element data for the requested postImage</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public PostImage getPostImage(string key) {
      return mPostImage.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the postImage list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getPostImage contains real data. Otherwise, the result of getPostImage contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getPostImage(string)"/>
    /// <param name="key">primary key of the postImage to fetch</param>
    /// <returns>Existence.YES if the postImage exists, Existence.NO if the postImage does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasPostImage(string key) {
        return getPostImage(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the profileBox list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of profile boxes for the local user. Each profile box 
    /// contains a number of profile box items. The profile box items themselves are stored in 
    /// the separate profileBoxItems list. The name and author of the profileBox is taken from 
    /// the referenced listTpa entry. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the profileBox to fetch</param>
    /// <returns>the element data for the requested profileBox</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ProfileBox getProfileBox(string key) {
      return getMapValue(new ListId("profileBox"), key, typeof(ProfileBox));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the profileBox list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getProfileBox contains real data. Otherwise, the result of getProfileBox contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getProfileBox(string)"/>
    /// <param name="key">primary key of the profileBox to fetch</param>
    /// <returns>Existence.YES if the profileBox exists, Existence.NO if the profileBox does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasProfileBox(string key) {
        return getProfileBox(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the profileBox list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getProfileBox(string)"/>
    /// <returns>the element data for the requested profileBox</returns>
    public StateAwareList<ProfileBox> getProfileBoxList() {
        return getList(new ListId("profileBox"), typeof(ProfileBox));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the profileBoxItem list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of profile box items for the local user. Each profile 
    /// box item is the child of a profile box through parentBoxId. Orphan profile box items 
    /// (items for which a corresponding profile box in the profileBox list) will be ignored by 
    /// the UI 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the profileBoxItem to fetch</param>
    /// <returns>the element data for the requested profileBoxItem</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public ProfileBoxItem getProfileBoxItem(string key) {
      return getMapValue(new ListId("profileBoxItem"), key, typeof(ProfileBoxItem));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the profileBoxItem list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getProfileBoxItem contains real data. Otherwise, the result of getProfileBoxItem contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getProfileBoxItem(string)"/>
    /// <param name="key">primary key of the profileBoxItem to fetch</param>
    /// <returns>Existence.YES if the profileBoxItem exists, Existence.NO if the profileBoxItem does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasProfileBoxItem(string key) {
        return getProfileBoxItem(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the profileBoxItem list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getProfileBoxItem(string)"/>
    /// <returns>the element data for the requested profileBoxItem</returns>
    public StateAwareList<ProfileBoxItem> getProfileBoxItemList() {
        return getList(new ListId("profileBoxItem"), typeof(ProfileBoxItem));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the recentChannelPosts list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of channel posts of all subscribed channels. 
    /// </p>
    /// <p>
    /// 
    /// This does not support remove, change and elements messages. It only supports 
    /// requestListAll. 
    /// </p>
    /// <p>
    /// 
    /// This list returns fixed number of most recent cached channel posts from the db. Limit is 
    /// configurable in bbmcore. 
    /// </p>
    /// <p>
    /// 
    /// Returns list in descending order by the time the post was created. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the recentChannelPosts to fetch</param>
    /// <returns>the element data for the requested recentChannelPosts</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public RecentChannelPosts getRecentChannelPosts(string key) {
      return getMapValue(new ListId("recentChannelPosts"), key, typeof(RecentChannelPosts));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the recentChannelPosts list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getRecentChannelPosts contains real data. Otherwise, the result of getRecentChannelPosts contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getRecentChannelPosts(string)"/>
    /// <param name="key">primary key of the recentChannelPosts to fetch</param>
    /// <returns>Existence.YES if the recentChannelPosts exists, Existence.NO if the recentChannelPosts does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasRecentChannelPosts(string key) {
        return getRecentChannelPosts(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the recentChannelPosts list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getRecentChannelPosts(string)"/>
    /// <returns>the element data for the requested recentChannelPosts</returns>
    public StateAwareList<RecentChannelPosts> getRecentChannelPostsList() {
        return getList(new ListId("recentChannelPosts"), typeof(RecentChannelPosts));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the recentUpdate list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of recent updates for the user's contact list. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the recentUpdate to fetch</param>
    /// <returns>the element data for the requested recentUpdate</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public RecentUpdate getRecentUpdate(string key) {
      return getMapValue(new ListId("recentUpdate"), key, typeof(RecentUpdate));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the recentUpdate list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getRecentUpdate contains real data. Otherwise, the result of getRecentUpdate contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getRecentUpdate(string)"/>
    /// <param name="key">primary key of the recentUpdate to fetch</param>
    /// <returns>Existence.YES if the recentUpdate exists, Existence.NO if the recentUpdate does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasRecentUpdate(string key) {
        return getRecentUpdate(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the recentUpdate list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getRecentUpdate(string)"/>
    /// <returns>the element data for the requested recentUpdate</returns>
    public StateAwareList<RecentUpdate> getRecentUpdateList() {
        return getList(new ListId("recentUpdate"), typeof(RecentUpdate));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the recommendedChannel list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds the set of BBM Channel URIs that have been recommended to user, also 
    /// known as pushed by RIM admin channels. 
    /// </p>
    /// <p>
    /// 
    /// If user chooses to join the recommended channel, UI sends channelSubscribe message 
    /// with the channel URI to core. Core replies to this message with either a 'listAdd' or a 
    /// 'channelSubscribeError' message. If channel subscription goes through, user will 
    /// be subscribed to the channel. 
    /// </p>
    /// <p>
    /// 
    /// If user chooses to ignore the recommended channel, UI sends 
    /// channelIgnoreRecommended message with the channel URI to core. Core replies to this 
    /// message with 'listRemove' and removes the channel URI from the list. 
    /// </p>
    /// <p>
    /// 
    /// At any time core can add new recommended channels to this list by listAdd. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the recommendedChannel to fetch</param>
    /// <returns>the element data for the requested recommendedChannel</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public RecommendedChannel getRecommendedChannel(string key) {
      return getMapValue(new ListId("recommendedChannel"), key, typeof(RecommendedChannel));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the recommendedChannel list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getRecommendedChannel contains real data. Otherwise, the result of getRecommendedChannel contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getRecommendedChannel(string)"/>
    /// <param name="key">primary key of the recommendedChannel to fetch</param>
    /// <returns>Existence.YES if the recommendedChannel exists, Existence.NO if the recommendedChannel does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasRecommendedChannel(string key) {
        return getRecommendedChannel(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the recommendedChannel list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getRecommendedChannel(string)"/>
    /// <returns>the element data for the requested recommendedChannel</returns>
    public StateAwareList<RecommendedChannel> getRecommendedChannelList() {
        return getList(new ListId("recommendedChannel"), typeof(RecommendedChannel));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the status list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This singleton list holds the set of available status messages for the user. There is no 
    /// requirement that the user select one of these messages. They are only used as a palette 
    /// of available messages. 
    /// </p>
    /// <p>
    /// 
    /// Status messages are inserted into this list using the requestListAdd message. When 
    /// sending a requestListAdd, the readOnly attribute must not be included since it is 
    /// assigned by core. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the status to fetch</param>
    /// <returns>the element data for the requested status</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Status getStatus(string key) {
      return getMapValue(new ListId("status"), key, typeof(Status));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the status list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getStatus contains real data. Otherwise, the result of getStatus contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getStatus(string)"/>
    /// <param name="key">primary key of the status to fetch</param>
    /// <returns>Existence.YES if the status exists, Existence.NO if the status does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasStatus(string key) {
        return getStatus(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the status list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getStatus(string)"/>
    /// <returns>the element data for the requested status</returns>
    public StateAwareList<Status> getStatusList() {
        return getList(new ListId("status"), typeof(Status));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the sticker list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds all the stickers on the device, both owned stickers and 
    /// received/cached stickers. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the sticker to fetch</param>
    /// <returns>the element data for the requested sticker</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Sticker getSticker(string key) {
      return mSticker.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the sticker list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getSticker contains real data. Otherwise, the result of getSticker contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getSticker(string)"/>
    /// <param name="key">primary key of the sticker to fetch</param>
    /// <returns>Existence.YES if the sticker exists, Existence.NO if the sticker does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasSticker(string key) {
        return getSticker(key).getExists();
    }
    
    /// <summary>
    /// Returns the elements from the sticker list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getSticker(string)"/>
    /// <returns>the element data for the requested sticker matching the criteria</returns>
    public StateAwareList<Sticker> getStickerList(StickerCriteria criteria) {
        return getListMatching(new ListId("sticker"), typeof(Sticker), criteria);
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the stickerImage list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list holds all the stickerImages from all the stickers on the device, both owned 
    /// stickers and received/cached stickers. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the stickerImage to fetch</param>
    /// <returns>the element data for the requested stickerImage</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public StickerImage getStickerImage(string key) {
      return mStickerImage.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the stickerImage list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getStickerImage contains real data. Otherwise, the result of getStickerImage contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getStickerImage(string)"/>
    /// <param name="key">primary key of the stickerImage to fetch</param>
    /// <returns>Existence.YES if the stickerImage exists, Existence.NO if the stickerImage does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasStickerImage(string key) {
        return getStickerImage(key).getExists();
    }
    
    /// <summary>
    /// Returns the elements from the stickerImage list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getStickerImage(string)"/>
    /// <returns>the element data for the requested stickerImage matching the criteria</returns>
    public StateAwareList<StickerImage> getStickerImageList(StickerImageCriteria criteria) {
        return getListMatching(new ListId("stickerImage"), typeof(StickerImage), criteria);
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the stickerPack list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list consists of all known BBM Sticker Packs -- those owned (and contained in the 
    /// localStickerPack list) and those we downloaded in response to having received a 
    /// sticker from a sticker pack we don't own. 
    /// </p>
    /// <p>
    /// 
    /// The owned sticker packs are stored locally. When a sticker is received from someone, 
    /// and we don't already own the sticker pack that it's from, we download the sticker pack 
    /// JSON file, parse it and add it to this list, then download just the referenced image(s) 
    /// needed for the received sticker. It's cached locally but unlike owned sticker packs, 
    /// can be removed at any time. 
    /// </p>
    /// <p>
    /// 
    /// Unless otherwise specified, all fields are limited to 255 Unicode code points and must 
    /// not contain the control characters [U+0000, U+001F] or U+007F. 
    /// </p>
    /// <p>
    /// 
    /// Core will send 'listAdd' and 'listRemove' for this list even though it is 'map-only'. 
    /// When a 'listRemove' is sent for a 'stickerPack' entry, UI must invalidate (i.e. 
    /// forget) all subordinate elements in the 'sticker' and 'stickerImage' lists. No 
    /// 'listAdd' or 'listRemove' messages will be sent for those lists. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the stickerPack to fetch</param>
    /// <returns>the element data for the requested stickerPack</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public StickerPack getStickerPack(string key) {
      return mStickerPack.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the stickerPack list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getStickerPack contains real data. Otherwise, the result of getStickerPack contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getStickerPack(string)"/>
    /// <param name="key">primary key of the stickerPack to fetch</param>
    /// <returns>Existence.YES if the stickerPack exists, Existence.NO if the stickerPack does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasStickerPack(string key) {
        return getStickerPack(key).getExists();
    }
    
    /// <summary>
    /// Returns the elements from the stickerPack list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getStickerPack(string)"/>
    /// <returns>the element data for the requested stickerPack matching the criteria</returns>
    public StateAwareList<StickerPack> getStickerPackList(StickerPackCriteria criteria) {
        return getListMatching(new ListId("stickerPack"), typeof(StickerPack), criteria);
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the textMessageContext list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This map-only list includes all referenced contextual information that the user sent 
    /// or received with text messages of type 'TextWithContext'. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the textMessageContext to fetch</param>
    /// <returns>the element data for the requested textMessageContext</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public TextMessageContext getTextMessageContext(string key) {
      return mTextMessageContext.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the textMessageContext list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getTextMessageContext contains real data. Otherwise, the result of getTextMessageContext contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTextMessageContext(string)"/>
    /// <param name="key">primary key of the textMessageContext to fetch</param>
    /// <returns>Existence.YES if the textMessageContext exists, Existence.NO if the textMessageContext does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasTextMessageContext(string key) {
        return getTextMessageContext(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the tpa list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is the list of all registered TPAs and their metadata 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the tpa to fetch</param>
    /// <returns>the element data for the requested tpa</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Tpa getTpa(string key) {
      return getMapValue(new ListId("tpa"), key, typeof(Tpa));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the tpa list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getTpa contains real data. Otherwise, the result of getTpa contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTpa(string)"/>
    /// <param name="key">primary key of the tpa to fetch</param>
    /// <returns>Existence.YES if the tpa exists, Existence.NO if the tpa does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasTpa(string key) {
        return getTpa(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the tpa list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTpa(string)"/>
    /// <returns>the element data for the requested tpa</returns>
    public StateAwareList<Tpa> getTpaList() {
        return getList(new ListId("tpa"), typeof(Tpa));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the tpaDownloadInvitation list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list contains the download invitations for the bbm social platform. This 
    /// singleton list is referenced by the message list to embed download invitations in the 
    /// chat history. Valid statuses are as follows: 
    /// </p>
    /// <p>
    /// 
    /// Pending: The user has not yet responded to this invitation 
    /// </p>
    /// <p>
    /// 
    /// Accepted: The user has already accepted this invitation 
    /// </p>
    /// <p>
    /// 
    /// Declined: The user has already declined this invitation 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the tpaDownloadInvitation to fetch</param>
    /// <returns>the element data for the requested tpaDownloadInvitation</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public TpaDownloadInvitation getTpaDownloadInvitation(string key) {
      return getMapValue(new ListId("tpaDownloadInvitation"), key, typeof(TpaDownloadInvitation));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the tpaDownloadInvitation list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getTpaDownloadInvitation contains real data. Otherwise, the result of getTpaDownloadInvitation contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTpaDownloadInvitation(string)"/>
    /// <param name="key">primary key of the tpaDownloadInvitation to fetch</param>
    /// <returns>Existence.YES if the tpaDownloadInvitation exists, Existence.NO if the tpaDownloadInvitation does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasTpaDownloadInvitation(string key) {
        return getTpaDownloadInvitation(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the tpaDownloadInvitation list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTpaDownloadInvitation(string)"/>
    /// <returns>the element data for the requested tpaDownloadInvitation</returns>
    public StateAwareList<TpaDownloadInvitation> getTpaDownloadInvitationList() {
        return getList(new ListId("tpaDownloadInvitation"), typeof(TpaDownloadInvitation));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the typingUser list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This is used to store the set of users that are currently typing a message to the local 
    /// user. When bbmcore believes the remote user to be typing a message in a conversation, it 
    /// will insert the user/conversation pair into this list. When it no longer believes the 
    /// user to be typing a message, it removes the pair from the list. The same user may be typing 
    /// in multiple conversations, and the same conversation may contain multiple typing 
    /// users. This list may also contain entries for nonexistent users and conversations. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the typingUser to fetch</param>
    /// <returns>the element data for the requested typingUser</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public TypingUser getTypingUser(string key) {
      return getMapValue(new ListId("typingUser"), key, typeof(TypingUser));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the typingUser list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getTypingUser contains real data. Otherwise, the result of getTypingUser contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTypingUser(string)"/>
    /// <param name="key">primary key of the typingUser to fetch</param>
    /// <returns>Existence.YES if the typingUser exists, Existence.NO if the typingUser does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasTypingUser(string key) {
        return getTypingUser(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the typingUser list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getTypingUser(string)"/>
    /// <returns>the element data for the requested typingUser</returns>
    public StateAwareList<TypingUser> getTypingUserList() {
        return getList(new ListId("typingUser"), typeof(TypingUser));
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the user list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list consists of all the users known to core including the contact list, 
    /// conversation participants that aren't included in the contact list, ignored users, 
    /// users that are the subject or origin of a pending invitation, and any other user that is 
    /// ever referenced by core. The UI never requests the list in full. Instead, it uses 
    /// restricted requestListElements calls with the optional 'elements' restriction in 
    /// order to ask core 'tell me what you know about the user that has this URI'. 
    /// </p>
    /// <p>
    /// 
    /// This list is the mechanism by which the UI obtains display names and other metadata for 
    /// conversation participants that aren't members of the contact list. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the user to fetch</param>
    /// <returns>the element data for the requested user</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public User getUser(string key) {
      return mUser.get(key).get();
    }
    
    /// <summary>
    /// Determines whether the given element exists in the user list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getUser contains real data. Otherwise, the result of getUser contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getUser(string)"/>
    /// <param name="key">primary key of the user to fetch</param>
    /// <returns>Existence.YES if the user exists, Existence.NO if the user does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasUser(string key) {
        return getUser(key).getExists();
    }
    
    /// <summary>
    /// <p>
    /// Returns a single element from the userBlockedItem list. If the element is in the process of being fetched or doesn't exist, this returns an empty JSONObject.
    /// </p>
    /// <p>
    /// This list controls granular blocking of items on a per-User basis. Each entry will 
    /// cause bbmcore to block that particular item from having any effect whenever the 
    /// event(s) related to that item occur. 
    /// </p>
    /// <p>
    /// 
    /// For example, an entry of type ContactInvitation for a User will instruct bbmcore to 
    /// ignore any incoming BBM Contact invitations from any of that User's network 
    /// identities. An entry of type RecentUpdatePersonalMessage will instruct bbmcore to 
    /// omit an entry from the Recent Updates list whenever the User changes their personal 
    /// message. An entry of type NowPlaying will cause bbmcore to ignore all incoming media 
    /// update messages from the User. 
    /// </p>
    /// <p>
    /// 
    /// The special 'All' type is provided as an optimization and is treated by bbmcore as if all 
    /// other types had been specified individually. This has an additional feature of 
    /// applying the blocking to any future Apps that are installed while the 'All' setting is 
    /// enabled. 
    /// </p>
    /// <p>
    /// 
    /// Mulitple items of type RecentUpdateApp may be specified per User, and require that the 
    /// typeUri field be supplied with the particular URI of the App whose recent updates 
    /// should be blocked. 
    /// </p>
    /// <p>
    /// 
    /// Adding a new entry to the list will delete any existing items of that type for the User. 
    /// For example, adding an entry of type RecentUpdateAvatar will delete any existing 
    /// avatar-related recent update elements for the User. 
    /// </p>
    /// <p>
    /// 
    /// Removing an entry from the list will allow new items of that type to be added. Items 
    /// ignored while blocking was enabled will not be added. 
    /// </p>
    /// <p>
    /// 
    /// The requestListAll message is supported for this list, and will return all blocked 
    /// items for all Users. 
    /// </p>
    /// <p>
    /// 
    /// The requestListElements message is supported for this list, and can be used to lookup 
    /// an individual blocked item. 
    /// </p>
    /// <p>
    /// 
    /// The requestListMatching message is supported for this list, and can be used to lookup 
    /// arbitrary subsets of this list based on the allowed criteria. 
    /// </p>
    /// <p>
    /// 
    /// The requestListChange message is not supported for this list. 
    /// </p>
    /// <p>
    /// 
    /// BBMDS clients may request elements of this list either via the primary key (itemId) or 
    /// via the composite key [userUri, type], although this composite key is not necessarily 
    /// unique. 
    /// </p>
     
    /// </summary>
    /// <param name="key">primary key of the userBlockedItem to fetch</param>
    /// <returns>the element data for the requested userBlockedItem</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public UserBlockedItem getUserBlockedItem(string key) {
      return getMapValue(new ListId("userBlockedItem"), key, typeof(UserBlockedItem));
    }
    
    /// <summary>
    /// Determines whether the given element exists in the userBlockedItem list. Invoking this method will cause the element to be fetched if it has not been fetched yet. If state is Existence.YES, the matching element returned from getUserBlockedItem contains real data. Otherwise, the result of getUserBlockedItem contains a temporary placeholder.
    /// </summary>
    /// <see cref="BbmdsProtocol#getUserBlockedItem(string)"/>
    /// <param name="key">primary key of the userBlockedItem to fetch</param>
    /// <returns>Existence.YES if the userBlockedItem exists, Existence.NO if the userBlockedItem does not exist, and Existence.MAYBE if the broker is still waiting for a response.</returns>
    @TrackedGetter
    // AA: this method has "throws Tracked" clause and C# don't have equivalent conversion #FYI
    public Existence hasUserBlockedItem(string key) {
        return getUserBlockedItem(key).getExists();
    }
    
    /// <summary>
    /// Returns all elements from the userBlockedItem list.
    /// </summary>
    /// <see cref="BbmdsProtocol#getUserBlockedItem(string)"/>
    /// <returns>the element data for the requested userBlockedItem</returns>
    public StateAwareList<UserBlockedItem> getUserBlockedItemList() {
        return getList(new ListId("userBlockedItem"), typeof(UserBlockedItem));
    }
    
    /// <summary>
    /// Returns the elements from the userBlockedItem list that match the given criteria.
    /// </summary>
    /// <see cref="BbmdsProtocol#getUserBlockedItem(string)"/>
    /// <returns>the element data for the requested userBlockedItem matching the criteria</returns>
    public StateAwareList<UserBlockedItem> getUserBlockedItemList(UserBlockedItemCriteria criteria) {
        return getListMatching(new ListId("userBlockedItem"), typeof(UserBlockedItem), criteria);
    }
      
    /// <summary>
    /// Returns all elements from the channelPost list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="\BbmdsProtocol#getChannelPost(string)"/>
    /// <param name="id">The channel URI of the channel whose posts need to be retrieved</param>
    /// <returns>the element data for the requested channelPost</returns>
    public StateAwareSparseList<ChannelPost> getChannelPostList(string id, bool descending) {
        return getSparseList(new ListId("channelPost", id), descending, typeof(ChannelPost));
    }
      
    /// <summary>
    /// Returns all elements from the channelPostComment list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="\BbmdsProtocol#getChannelPostComment(string)"/>
    /// <param name="id">The IDs are a space separated concatenation of the channel Id and the external post Id for this list of comments</param>
    /// <returns>the element data for the requested channelPostComment</returns>
    public StateAwareSparseList<ChannelPostComment> getChannelPostCommentList(string id, bool descending) {
        return getSparseList(new ListId("channelPostComment", id), descending, typeof(ChannelPostComment));
    }
      
    /// <summary>
    /// Returns all elements from the searchedChannel list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="\BbmdsProtocol#getSearchedChannel(string)"/>
    /// <param name="id">The IDs are unique identifiers that carry no semantic meaning beyond uniquely identifying a search. The ID-keyword match is defined in searchChannels request. If such pair has not been defined, core should return no elements in the sparseList.</param>
    /// <returns>the element data for the requested searchedChannel</returns>
    public StateAwareSparseList<SearchedChannel> getSearchedChannelList(string id, bool descending) {
        return getSparseList(new ListId("searchedChannel", id), descending, typeof(SearchedChannel));
    }
      
    /// <summary>
    /// Returns all elements from the searchedChannelSubscriber list. This is a nonsingleton list, so the list must be identified using its id.
    /// </summary>
    /// <see cref="\BbmdsProtocol#getSearchedChannelSubscriber(string)"/>
    /// <param name="id">The ID is the channel ID for which the subscriber list should be retrieved.</param>
    /// <returns>the element data for the requested searchedChannelSubscriber</returns>
    public StateAwareSparseList<SearchedChannelSubscriber> getSearchedChannelSubscriberList(string id, bool descending) {
        return getSparseList(new ListId("searchedChannelSubscriber", id), descending, typeof(SearchedChannelSubscriber));
    }
    
    /// <summary>
    /// Returns the schema for all lists in the protocol.
    /// </summary>
    private static ProtocolSchema createSchema() {
        readonly ProtocolSchema schema = new ProtocolSchema();
        // callEvent list
        List<string> callEventKeys = new ArrayList<string>();
        callEventKeys.add("id");
        ListDescriptor callEventDescr = new ListDescriptor("callEvent", callEventKeys);
        callEventDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(callEventDescr);

        // category list
        List<string> categoryKeys = new ArrayList<string>();
        categoryKeys.add("id");
        ListDescriptor categoryDescr = new ListDescriptor("category", categoryKeys);
        categoryDescr.setSingleton(true).setSupportsLiveList(true);
        categoryDescr.setDefault("canDelete","True");
        schema.putDescriptor(categoryDescr);

        // categoryContents list
        List<string> categoryContentsKeys = new ArrayList<string>();
        categoryContentsKeys.add("userUri");
        ListDescriptor categoryContentsDescr = new ListDescriptor("categoryContents", categoryContentsKeys);
        categoryContentsDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(categoryContentsDescr);

        // channel list
        List<string> channelKeys = new ArrayList<string>();
        channelKeys.add("uri");
        ListDescriptor channelDescr = new ListDescriptor("channel", channelKeys);
        channelDescr.setSingleton(true).setSupportsLiveList(false);
        channelDescr.setDefault("badge","True");
        channelDescr.setDefault("flagged","False");
        channelDescr.setDefault("hideUpdate","False");
        channelDescr.setDefault("isBlocked","False");
        channelDescr.setDefault("isPrivate","False");
        channelDescr.setDefault("notificationsEnabled","True");
        channelDescr.setDefault("officeHoursAlwaysAvailable","True");
        schema.putDescriptor(channelDescr);

        // channelCategory list
        List<string> channelCategoryKeys = new ArrayList<string>();
        channelCategoryKeys.add("id");
        ListDescriptor channelCategoryDescr = new ListDescriptor("channelCategory", channelCategoryKeys);
        channelCategoryDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(channelCategoryDescr);

        // channelConversation list
        List<string> channelConversationKeys = new ArrayList<string>();
        channelConversationKeys.add("id");
        ListDescriptor channelConversationDescr = new ListDescriptor("channelConversation", channelConversationKeys);
        channelConversationDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(channelConversationDescr);

        // channelInvitation list
        List<string> channelInvitationKeys = new ArrayList<string>();
        channelInvitationKeys.add("id");
        ListDescriptor channelInvitationDescr = new ListDescriptor("channelInvitation", channelInvitationKeys);
        channelInvitationDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(channelInvitationDescr);

        // channelNotification list
        List<string> channelNotificationKeys = new ArrayList<string>();
        channelNotificationKeys.add("id");
        ListDescriptor channelNotificationDescr = new ListDescriptor("channelNotification", channelNotificationKeys);
        channelNotificationDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(channelNotificationDescr);

        // channelSearchQuery list
        List<string> channelSearchQueryKeys = new ArrayList<string>();
        channelSearchQueryKeys.add("searchId");
        ListDescriptor channelSearchQueryDescr = new ListDescriptor("channelSearchQuery", channelSearchQueryKeys);
        channelSearchQueryDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(channelSearchQueryDescr);

        // channelStats list
        List<string> channelStatsKeys = new ArrayList<string>();
        channelStatsKeys.add("id");
        ListDescriptor channelStatsDescr = new ListDescriptor("channelStats", channelStatsKeys);
        channelStatsDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(channelStatsDescr);

        // channelSubCategory list
        List<string> channelSubCategoryKeys = new ArrayList<string>();
        channelSubCategoryKeys.add("id");
        ListDescriptor channelSubCategoryDescr = new ListDescriptor("channelSubCategory", channelSubCategoryKeys);
        channelSubCategoryDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(channelSubCategoryDescr);

        // comment list
        List<string> commentKeys = new ArrayList<string>();
        commentKeys.add("channelUri");
        commentKeys.add("postId");
        commentKeys.add("id");
        ListDescriptor commentDescr = new ListDescriptor("comment", commentKeys);
        commentDescr.setSingleton(true).setSupportsLiveList(false);
        commentDescr.setDefault("commentCount","0");
        commentDescr.setDefault("isBlocked","False");
        schema.putDescriptor(commentDescr);

        // conferenceInvitation list
        List<string> conferenceInvitationKeys = new ArrayList<string>();
        conferenceInvitationKeys.add("id");
        ListDescriptor conferenceInvitationDescr = new ListDescriptor("conferenceInvitation", conferenceInvitationKeys);
        conferenceInvitationDescr.setSingleton(true).setSupportsLiveList(true);
        conferenceInvitationDescr.setDefault("status","Pending");
        schema.putDescriptor(conferenceInvitationDescr);

        // contact list
        List<string> contactKeys = new ArrayList<string>();
        contactKeys.add("uri");
        ListDescriptor contactDescr = new ListDescriptor("contact", contactKeys);
        contactDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(contactDescr);

        // conversation list
        List<string> conversationKeys = new ArrayList<string>();
        conversationKeys.add("conversationUri");
        ListDescriptor conversationDescr = new ListDescriptor("conversation", conversationKeys);
        conversationDescr.setSingleton(true).setSupportsLiveList(true);
        conversationDescr.setDefault("draftMessage","");
        conversationDescr.setDefault("externalId","");
        conversationDescr.setDefault("numMessages","0");
        conversationDescr.setDefault("ownerUri","");
        conversationDescr.setDefault("visible","True");
        schema.putDescriptor(conversationDescr);

        // featuredChannel list
        List<string> featuredChannelKeys = new ArrayList<string>();
        featuredChannelKeys.add("uri");
        ListDescriptor featuredChannelDescr = new ListDescriptor("featuredChannel", featuredChannelKeys);
        featuredChannelDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(featuredChannelDescr);

        // featuredPost list
        List<string> featuredPostKeys = new ArrayList<string>();
        featuredPostKeys.add("channelUri");
        featuredPostKeys.add("id");
        ListDescriptor featuredPostDescr = new ListDescriptor("featuredPost", featuredPostKeys);
        featuredPostDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(featuredPostDescr);

        // fileTransfer list
        List<string> fileTransferKeys = new ArrayList<string>();
        fileTransferKeys.add("id");
        ListDescriptor fileTransferDescr = new ListDescriptor("fileTransfer", fileTransferKeys);
        fileTransferDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(fileTransferDescr);

        // flaggedChannelPost list
        List<string> flaggedChannelPostKeys = new ArrayList<string>();
        flaggedChannelPostKeys.add("channelUri");
        flaggedChannelPostKeys.add("id");
        ListDescriptor flaggedChannelPostDescr = new ListDescriptor("flaggedChannelPost", flaggedChannelPostKeys);
        flaggedChannelPostDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(flaggedChannelPostDescr);

        // flaggedChannelPostComment list
        List<string> flaggedChannelPostCommentKeys = new ArrayList<string>();
        flaggedChannelPostCommentKeys.add("channelUri");
        flaggedChannelPostCommentKeys.add("postId");
        flaggedChannelPostCommentKeys.add("id");
        ListDescriptor flaggedChannelPostCommentDescr = new ListDescriptor("flaggedChannelPostComment", flaggedChannelPostCommentKeys);
        flaggedChannelPostCommentDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(flaggedChannelPostCommentDescr);

        // global list
        List<string> globalKeys = new ArrayList<string>();
        globalKeys.add("name");
        ListDescriptor globalDescr = new ListDescriptor("global", globalKeys);
        globalDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(globalDescr);

        // localChannel list
        List<string> localChannelKeys = new ArrayList<string>();
        localChannelKeys.add("uri");
        ListDescriptor localChannelDescr = new ListDescriptor("localChannel", localChannelKeys);
        localChannelDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(localChannelDescr);

        // localStickerPack list
        List<string> localStickerPackKeys = new ArrayList<string>();
        localStickerPackKeys.add("id");
        ListDescriptor localStickerPackDescr = new ListDescriptor("localStickerPack", localStickerPackKeys);
        localStickerPackDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(localStickerPackDescr);

        // location list
        List<string> locationKeys = new ArrayList<string>();
        locationKeys.add("id");
        ListDescriptor locationDescr = new ListDescriptor("location", locationKeys);
        locationDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(locationDescr);

        // message list
        List<string> messageKeys = new ArrayList<string>();
        messageKeys.add("conv");
        messageKeys.add("id");
        ListDescriptor messageDescr = new ListDescriptor("message", messageKeys);
        messageDescr.setSingleton(true).setSupportsLiveList(false);
        messageDescr.setDefault("type","Text");
        schema.putDescriptor(messageDescr);

        // pendingContact list
        List<string> pendingContactKeys = new ArrayList<string>();
        pendingContactKeys.add("id");
        ListDescriptor pendingContactDescr = new ListDescriptor("pendingContact", pendingContactKeys);
        pendingContactDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(pendingContactDescr);

        // pendingPost list
        List<string> pendingPostKeys = new ArrayList<string>();
        pendingPostKeys.add("id");
        ListDescriptor pendingPostDescr = new ListDescriptor("pendingPost", pendingPostKeys);
        pendingPostDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(pendingPostDescr);

        // picture list
        List<string> pictureKeys = new ArrayList<string>();
        pictureKeys.add("id");
        ListDescriptor pictureDescr = new ListDescriptor("picture", pictureKeys);
        pictureDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(pictureDescr);

        // pinToUser list
        List<string> pinToUserKeys = new ArrayList<string>();
        pinToUserKeys.add("pin");
        ListDescriptor pinToUserDescr = new ListDescriptor("pinToUser", pinToUserKeys);
        pinToUserDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(pinToUserDescr);

        // platformDisabledUsers list
        List<string> platformDisabledUsersKeys = new ArrayList<string>();
        platformDisabledUsersKeys.add("uri");
        ListDescriptor platformDisabledUsersDescr = new ListDescriptor("platformDisabledUsers", platformDisabledUsersKeys);
        platformDisabledUsersDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(platformDisabledUsersDescr);

        // platformIgnoredUsers list
        List<string> platformIgnoredUsersKeys = new ArrayList<string>();
        platformIgnoredUsersKeys.add("uri");
        ListDescriptor platformIgnoredUsersDescr = new ListDescriptor("platformIgnoredUsers", platformIgnoredUsersKeys);
        platformIgnoredUsersDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(platformIgnoredUsersDescr);

        // post list
        List<string> postKeys = new ArrayList<string>();
        postKeys.add("channelUri");
        postKeys.add("id");
        ListDescriptor postDescr = new ListDescriptor("post", postKeys);
        postDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(postDescr);

        // postImage list
        List<string> postImageKeys = new ArrayList<string>();
        postImageKeys.add("imageId");
        ListDescriptor postImageDescr = new ListDescriptor("postImage", postImageKeys);
        postImageDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(postImageDescr);

        // profileBox list
        List<string> profileBoxKeys = new ArrayList<string>();
        profileBoxKeys.add("boxId");
        ListDescriptor profileBoxDescr = new ListDescriptor("profileBox", profileBoxKeys);
        profileBoxDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(profileBoxDescr);

        // profileBoxItem list
        List<string> profileBoxItemKeys = new ArrayList<string>();
        profileBoxItemKeys.add("itemId");
        ListDescriptor profileBoxItemDescr = new ListDescriptor("profileBoxItem", profileBoxItemKeys);
        profileBoxItemDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(profileBoxItemDescr);

        // recentChannelPosts list
        List<string> recentChannelPostsKeys = new ArrayList<string>();
        recentChannelPostsKeys.add("id");
        ListDescriptor recentChannelPostsDescr = new ListDescriptor("recentChannelPosts", recentChannelPostsKeys);
        recentChannelPostsDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(recentChannelPostsDescr);

        // recentUpdate list
        List<string> recentUpdateKeys = new ArrayList<string>();
        recentUpdateKeys.add("id");
        ListDescriptor recentUpdateDescr = new ListDescriptor("recentUpdate", recentUpdateKeys);
        recentUpdateDescr.setSingleton(true).setSupportsLiveList(true);
        recentUpdateDescr.setDefault("tpaUri","");
        schema.putDescriptor(recentUpdateDescr);

        // recommendedChannel list
        List<string> recommendedChannelKeys = new ArrayList<string>();
        recommendedChannelKeys.add("uri");
        ListDescriptor recommendedChannelDescr = new ListDescriptor("recommendedChannel", recommendedChannelKeys);
        recommendedChannelDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(recommendedChannelDescr);

        // status list
        List<string> statusKeys = new ArrayList<string>();
        statusKeys.add("id");
        ListDescriptor statusDescr = new ListDescriptor("status", statusKeys);
        statusDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(statusDescr);

        // sticker list
        List<string> stickerKeys = new ArrayList<string>();
        stickerKeys.add("id");
        ListDescriptor stickerDescr = new ListDescriptor("sticker", stickerKeys);
        stickerDescr.setSingleton(true).setSupportsLiveList(false);
        stickerDescr.setDefault("hidden","False");
        schema.putDescriptor(stickerDescr);

        // stickerImage list
        List<string> stickerImageKeys = new ArrayList<string>();
        stickerImageKeys.add("id");
        ListDescriptor stickerImageDescr = new ListDescriptor("stickerImage", stickerImageKeys);
        stickerImageDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(stickerImageDescr);

        // stickerPack list
        List<string> stickerPackKeys = new ArrayList<string>();
        stickerPackKeys.add("id");
        ListDescriptor stickerPackDescr = new ListDescriptor("stickerPack", stickerPackKeys);
        stickerPackDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(stickerPackDescr);

        // textMessageContext list
        List<string> textMessageContextKeys = new ArrayList<string>();
        textMessageContextKeys.add("id");
        ListDescriptor textMessageContextDescr = new ListDescriptor("textMessageContext", textMessageContextKeys);
        textMessageContextDescr.setSingleton(true).setSupportsLiveList(false);
        schema.putDescriptor(textMessageContextDescr);

        // tpa list
        List<string> tpaKeys = new ArrayList<string>();
        tpaKeys.add("uri");
        ListDescriptor tpaDescr = new ListDescriptor("tpa", tpaKeys);
        tpaDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(tpaDescr);

        // tpaDownloadInvitation list
        List<string> tpaDownloadInvitationKeys = new ArrayList<string>();
        tpaDownloadInvitationKeys.add("id");
        ListDescriptor tpaDownloadInvitationDescr = new ListDescriptor("tpaDownloadInvitation", tpaDownloadInvitationKeys);
        tpaDownloadInvitationDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(tpaDownloadInvitationDescr);

        // typingUser list
        List<string> typingUserKeys = new ArrayList<string>();
        typingUserKeys.add("userUri");
        typingUserKeys.add("conversationUri");
        ListDescriptor typingUserDescr = new ListDescriptor("typingUser", typingUserKeys);
        typingUserDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(typingUserDescr);

        // user list
        List<string> userKeys = new ArrayList<string>();
        userKeys.add("uri");
        ListDescriptor userDescr = new ListDescriptor("user", userKeys);
        userDescr.setSingleton(true).setSupportsLiveList(false);
        userDescr.setDefault("avatarHash","");
        userDescr.setDefault("currentStatus","");
        userDescr.setDefault("displayName","");
        userDescr.setDefault("ecoid","");
        userDescr.setDefault("emailAddress","");
        userDescr.setDefault("installedApps","[]");
        userDescr.setDefault("location","");
        userDescr.setDefault("maxVcardSize","0");
        userDescr.setDefault("nickname","");
        userDescr.setDefault("nowPlayingMessage","");
        userDescr.setDefault("personalMessage","");
        userDescr.setDefault("personalMessageTpaUri","");
        userDescr.setDefault("pin","");
        userDescr.setDefault("pins","[]");
        userDescr.setDefault("timezone","");
        schema.putDescriptor(userDescr);

        // userBlockedItem list
        List<string> userBlockedItemKeys = new ArrayList<string>();
        userBlockedItemKeys.add("userUri");
        userBlockedItemKeys.add("type");
        userBlockedItemKeys.add("typeUri");
        ListDescriptor userBlockedItemDescr = new ListDescriptor("userBlockedItem", userBlockedItemKeys);
        userBlockedItemDescr.setSingleton(true).setSupportsLiveList(true);
        schema.putDescriptor(userBlockedItemDescr);

        // channelPost list
        List<string> channelPostKeys = new ArrayList<string>();
        channelPostKeys.add("id");
        ListDescriptor channelPostDescr = new ListDescriptor("channelPost", channelPostKeys);
        channelPostDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(channelPostDescr);

        // channelPostComment list
        List<string> channelPostCommentKeys = new ArrayList<string>();
        channelPostCommentKeys.add("id");
        ListDescriptor channelPostCommentDescr = new ListDescriptor("channelPostComment", channelPostCommentKeys);
        channelPostCommentDescr.setSingleton(false).setSupportsLiveList(true);
        channelPostCommentDescr.setDefault("commentCount","0");
        channelPostCommentDescr.setDefault("isBlocked","False");
        schema.putDescriptor(channelPostCommentDescr);

        // searchedChannel list
        List<string> searchedChannelKeys = new ArrayList<string>();
        searchedChannelKeys.add("id");
        ListDescriptor searchedChannelDescr = new ListDescriptor("searchedChannel", searchedChannelKeys);
        searchedChannelDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(searchedChannelDescr);

        // searchedChannelSubscriber list
        List<string> searchedChannelSubscriberKeys = new ArrayList<string>();
        searchedChannelSubscriberKeys.add("id");
        ListDescriptor searchedChannelSubscriberDescr = new ListDescriptor("searchedChannelSubscriber", searchedChannelSubscriberKeys);
        searchedChannelSubscriberDescr.setSingleton(false).setSupportsLiveList(true);
        schema.putDescriptor(searchedChannelSubscriberDescr);

        return schema;
    }

}
}