/***
 * This is an autogenerated file. DO NOT EDIT THIS FILE OR YOUR CHANGES WILL BE OVERWRITTEN! 
 * If you wish to make changes here, please update the documentation in the bbm_doc git 
 * repository and then rerun the updateschema.py2 script. 
 */

using System;
//using com.bbm.bbmds.internal.JsonConstructable;
using com.bbm.util.Existence;

using java.util.List;
using java.util.Collections;
namespace com.bbm.bbmds{
/// <summary>
/// <p>
/// This list consists of all the users known to core including the contact list, conversation 
/// participants that aren't included in the contact list, ignored users, users that are the 
/// subject or origin of a pending invitation, and any other user that is ever referenced by 
/// core. The UI never requests the list in full. Instead, it uses restricted 
/// requestListElements calls with the optional 'elements' restriction in order to ask core 
/// 'tell me what you know about the user that has this URI'. 
/// </p>
/// <p>
/// 
/// This list is the mechanism by which the UI obtains display names and other metadata for 
/// conversation participants that aren't members of the contact list. 
/// </p>
/// </summary>
public class User : JsonConstructable {
    /// <summary>
    /// The hash value for the contact's avatar if set.  If empty or not present, it indicates no avatar is set.
    /// </summary>
    public string avatarHash = "";
    
    /// <summary>
    /// Holds the user-readable status message. The string literals 'Busy' and 'Available' are treated specially and will be replaced with appropriate translations by the GUI. All other strings will be displayed verbatim. The empty string indicates that the status message is unknown.
    /// </summary>
    public string currentStatus = "";
    
    /// <summary>
    /// If present, this contains a UTC POSIX timestamp in seconds for the local user's date of birth. If omitted, the date of birth of the local user is unknown.
    /// </summary>
    public long dateOfBirth = 0;
    
    /// <summary>
    /// Holds the user-readable display name of this user. This is the name originally set by the remote user. The empty string indicates that the remote user's displayName is not known.
    /// </summary>
    public string displayName = "";
    
    /// <summary>
    /// Holds the user's BBID ecoid. EcoId will be empty for in-market BBM BBOS contacts as this feature is not implemented yet on BBM BBOS. EcoId will alway be present for BB10 contacts.
    /// </summary>
    public string ecoid = "";
    
    /// <summary>
    /// Holds the user's email address. The empty string indicates that the address is unknown.
    /// </summary>
    public string emailAddress = "";
    
    /// <summary>
    /// If present, this contains the local user's gender. If omitted, the gender of the local user is unknown.
    /// </summary>
    public string gender = "";
    
    /// <summary>
    /// Holds the list of apps that the remote user has installed, as a list of ids.
    /// </summary>
    public List<string> installedApps = Collections.emptyList();
    
    /// <summary>
    /// The remote user is sharing their location / timezone with us. This is the upper-case ISO Alpha-2 country code in which the remote user is currently or last reported to be. This can be set independently of timezone. The empty string indicates that the remote user's location is unknown.
    /// </summary>
    public string location = "";
    
    /// <summary>
    /// The maximum vcard size in KB that is allowed to be sent. This will always be set for any User we expect to send Vcards to. The zero value indicates that the user does not support receipt of Vcards.
    /// </summary>
    public double maxVcardSize = 0;
    
    /// <summary>
    /// Holds the user-readable display name of this user as it was set by the local user. This attribute is only nonempty in the case that the local user is using a nickname for a remote user.
    /// </summary>
    public string nickname = "";
    
    /// <summary>
    /// Holds the user's 'Show What I'm Listening To' message. The message may contain the media information of either the name of the artist or the name of the track or both. This message can be empty if no media is currently playing or the message is unknown.
    /// </summary>
    public string nowPlayingMessage = "";
    
    /// <summary>
    /// Holds the user's personal message. This is a user-readable string in the sender's language. The empty string indicates that the message is unknown.
    /// </summary>
    public string personalMessage = "";
    
    /// <summary>
    /// Holds the timestamp of the last change to the user's personal message, in POSIX format.
    /// </summary>
    public long personalMessageTimestamp = 0;
    
    /// <summary>
    /// Foreign key into listTpa referencing the application that changed the personal message. This should be displayed as a 'Tag' beside the message. If omitted or set to the empty string, it indicates that the status was not changed by a tpa.
    /// </summary>
    public string personalMessageTpaUri = "";
    
    /// <summary>
    /// Deprecated in 2.2. Replaced by the pins array. Holds the PIN of the user's device, as a 8-character lowercase hex string. The empty string indicates that the PIN is unknown.
    /// </summary>
    public string pin = "";
    
    /// <summary>
    /// Holds the list of pins for known devices of this user. The elements are 8-character lowercase hexidecimal strings.
    /// </summary>
    public List<string> pins = Collections.emptyList();
    
    /// <summary>
    /// Holds the user's busy state
    /// </summary>
    public bool showBusy = false;
    
    /// <summary>
    /// Boolean flag indicating whether or not the user is sharing their current (or last known) location / timezone information.
    /// </summary>
    public bool showLocationTimezone = false;
    
    /// <summary>
    /// Controls the system level notifications for the user.  If set to 'Default' the behavior is expected to be system defined.  By setting this to something other than 'Default' clients are hinting that they would like to force the behavior.  On BB10 this is used to control the behavior of instant replies - whether they should appear for a particular user.
    /// </summary>
    public string systemNotifications = "";
    
    /// <summary>
    /// The remote user is sharing their location / timezone with us. This is the Olson ID of the timezone in which the remote user is currently on or last reported to be. This can be set independently of location. The empty string indicates that the remote user's timezone is unknown.
    /// </summary>
    public string timezone = "";
    
    /// <summary>
    /// Holds the unique identifier for the user. See uriformats.txt for information on the URI format. This replaces the 'pin' attribute from protocol version 2.0, and one or the other is required.
    /// </summary>
    public string uri = "";
    
    /// <summary>
    /// Determines whether this element exists in the user list. If state is Existence.YES, this struct contains real data. Otherwise, all other attributes contain default placeholder data. If the state is Existence.NO, then we know for certain that this
    /// entity does not exist in the daemon. If the state is Existence.MAYBE, then we have not yet confirmed whether this entity exists in the daemon -- normally this is because the client has sent out a request to the daemon that it has not yet answered.
    /// </summary>
    public Existence exists = Existence.MAYBE;
    
    
    /// <summary>
    /// Creates a new instance with default values
    /// </summary>
    public User () {}
    
    /// <summary>
    /// Creates a shallow copy of the argument.
    /// </summary>
    /// <param name="toCopy">the object to copy</param>
    public User (User toCopy) {
        avatarHash = toCopy.avatarHash;
        currentStatus = toCopy.currentStatus;
        dateOfBirth = toCopy.dateOfBirth;
        displayName = toCopy.displayName;
        ecoid = toCopy.ecoid;
        emailAddress = toCopy.emailAddress;
        gender = toCopy.gender;
        installedApps = toCopy.installedApps;
        location = toCopy.location;
        maxVcardSize = toCopy.maxVcardSize;
        nickname = toCopy.nickname;
        nowPlayingMessage = toCopy.nowPlayingMessage;
        personalMessage = toCopy.personalMessage;
        personalMessageTimestamp = toCopy.personalMessageTimestamp;
        personalMessageTpaUri = toCopy.personalMessageTpaUri;
        pin = toCopy.pin;
        pins = toCopy.pins;
        showBusy = toCopy.showBusy;
        showLocationTimezone = toCopy.showLocationTimezone;
        systemNotifications = toCopy.systemNotifications;
        timezone = toCopy.timezone;
        uri = toCopy.uri;
        exists = toCopy.exists;
    }
    
    
    public override string getPrimaryKey() {
        return uri;
    }
    
    
    public override void setAttributes(JSONObject json) {
    
        avatarHash = json.optString("avatarHash", avatarHash);
        currentStatus = json.optString("currentStatus", currentStatus);
        
        if (json.has("dateOfBirth")) {
            string temp = json.optString("dateOfBirth", "");
            dateOfBirth = temp.isEmpty() ? 0 : Long.parseLong(temp);
        }
        displayName = json.optString("displayName", displayName);
        ecoid = json.optString("ecoid", ecoid);
        emailAddress = json.optString("emailAddress", emailAddress);
        gender = json.optString("gender", gender);
        if (json.has("installedApps")) {
            installedApps = com.google.common.collect.Lists.newArrayList();
            JSONArray temp = json.optJSONArray("installedApps");
            if(temp != null){
                for (int idx = 0; idx < temp.length(); idx++) {
                    !! Someone needs to write a converter for List<string>
                }
            }
        }
        location = json.optString("location", location);
        maxVcardSize = json.optDouble("maxVcardSize", maxVcardSize);
        nickname = json.optString("nickname", nickname);
        nowPlayingMessage = json.optString("nowPlayingMessage", nowPlayingMessage);
        personalMessage = json.optString("personalMessage", personalMessage);
        
        if (json.has("personalMessageTimestamp")) {
            string temp = json.optString("personalMessageTimestamp", "");
            personalMessageTimestamp = temp.isEmpty() ? 0 : Long.parseLong(temp);
        }
        personalMessageTpaUri = json.optString("personalMessageTpaUri", personalMessageTpaUri);
        pin = json.optString("pin", pin);
        if (json.has("pins")) {
            pins = com.google.common.collect.Lists.newArrayList();
            JSONArray temp = json.optJSONArray("pins");
            if(temp != null){
                for (int idx = 0; idx < temp.length(); idx++) {
                    !! Someone needs to write a converter for List<string>
                }
            }
        }
        showBusy = json.optBoolean("showBusy", showBusy);
        showLocationTimezone = json.optBoolean("showLocationTimezone", showLocationTimezone);
        systemNotifications = json.optString("systemNotifications", systemNotifications);
        timezone = json.optString("timezone", timezone);
        uri = json.optString("uri", uri);
    }
    
    
    public override JsonConstructable shallowCopy() {
        return new User(this);
    }
    
    public override void setExists(Existence exists) {
        this.exists = exists;
    }
    
    public override Existence getExists() {
        return exists;
    }
    
    
    public override int hashCode() {
    
        int prime = 31;
        int result = 1;
        result = prime * result + ((avatarHash == null) ? 0 : avatarHash.hashCode());
        result = prime * result + ((currentStatus == null) ? 0 : currentStatus.hashCode());
        result = prime * result + (int)dateOfBirth;
        result = prime * result + ((displayName == null) ? 0 : displayName.hashCode());
        result = prime * result + ((ecoid == null) ? 0 : ecoid.hashCode());
        result = prime * result + ((emailAddress == null) ? 0 : emailAddress.hashCode());
        result = prime * result + ((gender == null) ? 0 : gender.hashCode());
        result = prime * result + ((installedApps == null) ? 0 : installedApps.hashCode());
        result = prime * result + ((location == null) ? 0 : location.hashCode());
        result = prime * result + (int)maxVcardSize;
        result = prime * result + ((nickname == null) ? 0 : nickname.hashCode());
        result = prime * result + ((nowPlayingMessage == null) ? 0 : nowPlayingMessage.hashCode());
        result = prime * result + ((personalMessage == null) ? 0 : personalMessage.hashCode());
        result = prime * result + (int)personalMessageTimestamp;
        result = prime * result + ((personalMessageTpaUri == null) ? 0 : personalMessageTpaUri.hashCode());
        result = prime * result + ((pin == null) ? 0 : pin.hashCode());
        result = prime * result + ((pins == null) ? 0 : pins.hashCode());
        result = prime * result + (showBusy ? 1231 : 1237);
        result = prime * result + (showLocationTimezone ? 1231 : 1237);
        result = prime * result + ((systemNotifications == null) ? 0 : systemNotifications.hashCode());
        result = prime * result + ((timezone == null) ? 0 : timezone.hashCode());
        result = prime * result + ((uri == null) ? 0 : uri.hashCode());
        result = prime * result + ((exists == null) ? 0 : exists.hashCode());
        return result;
    }
    
    
    public override bool equals(Object obj) {
    
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        User other = (User) obj;
        if (avatarHash == null) {
            if (other.avatarHash != null) {
                return false;
            }
        } else if (!avatarHash.equals(other.avatarHash)) {
            return false;
        }
        if (currentStatus == null) {
            if (other.currentStatus != null) {
                return false;
            }
        } else if (!currentStatus.equals(other.currentStatus)) {
            return false;
        }
        if (dateOfBirth != (other.dateOfBirth)) {
            return false;
        }
        if (displayName == null) {
            if (other.displayName != null) {
                return false;
            }
        } else if (!displayName.equals(other.displayName)) {
            return false;
        }
        if (ecoid == null) {
            if (other.ecoid != null) {
                return false;
            }
        } else if (!ecoid.equals(other.ecoid)) {
            return false;
        }
        if (emailAddress == null) {
            if (other.emailAddress != null) {
                return false;
            }
        } else if (!emailAddress.equals(other.emailAddress)) {
            return false;
        }
        if (gender == null) {
            if (other.gender != null) {
                return false;
            }
        } else if (!gender.equals(other.gender)) {
            return false;
        }
        if (installedApps == null) {
            if (other.installedApps != null) {
                return false;
            }
        } else if (!installedApps.equals(other.installedApps)) {
            return false;
        }
        if (location == null) {
            if (other.location != null) {
                return false;
            }
        } else if (!location.equals(other.location)) {
            return false;
        }
        if (maxVcardSize != (other.maxVcardSize)) {
            return false;
        }
        if (nickname == null) {
            if (other.nickname != null) {
                return false;
            }
        } else if (!nickname.equals(other.nickname)) {
            return false;
        }
        if (nowPlayingMessage == null) {
            if (other.nowPlayingMessage != null) {
                return false;
            }
        } else if (!nowPlayingMessage.equals(other.nowPlayingMessage)) {
            return false;
        }
        if (personalMessage == null) {
            if (other.personalMessage != null) {
                return false;
            }
        } else if (!personalMessage.equals(other.personalMessage)) {
            return false;
        }
        if (personalMessageTimestamp != (other.personalMessageTimestamp)) {
            return false;
        }
        if (personalMessageTpaUri == null) {
            if (other.personalMessageTpaUri != null) {
                return false;
            }
        } else if (!personalMessageTpaUri.equals(other.personalMessageTpaUri)) {
            return false;
        }
        if (pin == null) {
            if (other.pin != null) {
                return false;
            }
        } else if (!pin.equals(other.pin)) {
            return false;
        }
        if (pins == null) {
            if (other.pins != null) {
                return false;
            }
        } else if (!pins.equals(other.pins)) {
            return false;
        }
        if (showBusy != (other.showBusy)) {
            return false;
        }
        if (showLocationTimezone != (other.showLocationTimezone)) {
            return false;
        }
        if (systemNotifications == null) {
            if (other.systemNotifications != null) {
                return false;
            }
        } else if (!systemNotifications.equals(other.systemNotifications)) {
            return false;
        }
        if (timezone == null) {
            if (other.timezone != null) {
                return false;
            }
        } else if (!timezone.equals(other.timezone)) {
            return false;
        }
        if (uri == null) {
            if (other.uri != null) {
                return false;
            }
        } else if (!uri.equals(other.uri)) {
            return false;
        }
        
        if (!exists.equals(other.exists)) {
            return false;
        }
        
        return true;
    }
}
}