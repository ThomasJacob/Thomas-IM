/***
 * This is an autogenerated file. DO NOT EDIT THIS FILE OR YOUR CHANGES WILL BE OVERWRITTEN! 
 * If you wish to make changes here, please update the documentation in the bbm_doc git 
 * repository and then rerun the updateschema.py2 script. 
 */

using System;
//using com.bbm.bbmds.internal.JsonConstructable;
using com.bbm.util.Existence;

namespace com.bbm.bbmds{
/// <summary>
/// <p>
/// This is used to store the set of users that are currently typing a message to the local user. 
/// When bbmcore believes the remote user to be typing a message in a conversation, it will 
/// insert the user/conversation pair into this list. When it no longer believes the user to be 
/// typing a message, it removes the pair from the list. The same user may be typing in multiple 
/// conversations, and the same conversation may contain multiple typing users. This list may 
/// also contain entries for nonexistent users and conversations. 
/// </p>
/// </summary>
public class TypingUser : JsonConstructable {
    /// <summary>
    /// Holds the unique identifier of a conversation in which the user is typing.
    /// </summary>
    public string conversationUri = "";
    
    /// <summary>
    /// Holds the unique identifier of the user that is currently typing.
    /// </summary>
    public string userUri = "";
    
    /// <summary>
    /// Determines whether this element exists in the user list. If state is Existence.YES, this struct contains real data. Otherwise, all other attributes contain default placeholder data. If the state is Existence.NO, then we know for certain that this
    /// entity does not exist in the daemon. If the state is Existence.MAYBE, then we have not yet confirmed whether this entity exists in the daemon -- normally this is because the client has sent out a request to the daemon that it has not yet answered.
    /// </summary>
    public Existence exists = Existence.MAYBE;
    
    
    /// <summary>
    /// Creates a new instance with default values
    /// </summary>
    public TypingUser () {}
    
    /// <summary>
    /// Creates a shallow copy of the argument.
    /// </summary>
    /// <param name="toCopy">the object to copy</param>
    public TypingUser (TypingUser toCopy) {
        conversationUri = toCopy.conversationUri;
        userUri = toCopy.userUri;
        exists = toCopy.exists;
    }
    
    
    public override string getPrimaryKey() {
        return userUri + "|" + conversationUri;
    }
    
    
    public override void setAttributes(JSONObject json) {
    
        conversationUri = json.optString("conversationUri", conversationUri);
        userUri = json.optString("userUri", userUri);
    }
    
    
    public override JsonConstructable shallowCopy() {
        return new TypingUser(this);
    }
    
    public override void setExists(Existence exists) {
        this.exists = exists;
    }
    
    public override Existence getExists() {
        return exists;
    }
    
    
    public override int hashCode() {
    
        int prime = 31;
        int result = 1;
        result = prime * result + ((conversationUri == null) ? 0 : conversationUri.hashCode());
        result = prime * result + ((userUri == null) ? 0 : userUri.hashCode());
        result = prime * result + ((exists == null) ? 0 : exists.hashCode());
        return result;
    }
    
    
    public override bool equals(Object obj) {
    
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        TypingUser other = (TypingUser) obj;
        if (conversationUri == null) {
            if (other.conversationUri != null) {
                return false;
            }
        } else if (!conversationUri.equals(other.conversationUri)) {
            return false;
        }
        if (userUri == null) {
            if (other.userUri != null) {
                return false;
            }
        } else if (!userUri.equals(other.userUri)) {
            return false;
        }
        
        if (!exists.equals(other.exists)) {
            return false;
        }
        
        return true;
    }
}
}